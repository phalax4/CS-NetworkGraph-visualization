<base href="https://www.cs.utexas.edu/~gouda/cs356sp09/midterm2/">
------------------------------------------------------------------------------
Mohamed G. Gouda                                                CS 356
Spring 2009                                                 	Midterm 2
------------------------------------------------------------------------------
Open Book                                                       75 minutes
------------------------------------------------------------------------------

1. (7 points)
A process p sends a continuous stream of msg(d) messages, where d is a
none negative integer, to process q. Every once in a while, the value d in a 
sent msg(d) is modified into another value d' before process q receives the 
modified msg(d'). (We assume that no other transmission errors, such as message
corruption, loss, or reorder, can affect the transmitted messages from process
p to process q.) To recover from message modification, process p sends three
consecutive copies of each sent msg(d) to process q. When process q receives 
three consecutive messages, say msg(d0), msg(d1), and msg(d2), from p and 
checks that at least two of the the three values d0, d1, and d2 are equal, then
process q stores the majority value in its local array "rcvd", otherwise 
process q discards the three messages. The data structures of processes p and
q are specified as follows:

	process p
	inp	sent : array [integer] of integer
	var	i    : integer			{index of sent; init. 0}
	begin
	...
	end

	process q
	var 	rcvd : array [integer] of integer,
		j    : integer,			{index of rcvd; init. 0}
		bff  : array [0..2] of integer,
		k    : 0..2			{index of bff; init. 0 }
	begin
	...
	end

Specify the actions of processes p and q.

Solution:

process p

begin

true -> send msg(data[i]) to q;
        send msg(data[i]) to q;
        send msg(data[i]) to q;
        i = i+1;
end

process q

begin
rcv msg(buf[k]) from p -> 
                k = k +3 1;
                if k=0 -> 
                   if (bff[0]=bff[1])v(bff[0]=bff[2]) -> rcvd[j]:=bff[0]
                   [] bff[1]=bff[2]                   -> rcvd[j]:=bff[1]
                   [] bff[0]!=bff[1]^bff[0]!=bff[2]^bff[1]!=bff[2]
                                                      -> skip
                   fi; j:=j+1
                fi
end
------------------------------------------------------------------------------

2. (6 points)
The protocol in Problem 1 is correct if message modification is restricted
as follows: If any message in the stream of messages from p to q is modified, 
then the next X messages from p to q are guaranteed not to be modified. What 
is the smallest value of X in this restriction? Briefly explain your answer.

Solution:

The smallest value of X in this restriction is 2 in order to guarantee
the at least two messages out of the three consecutive copies are not
corrupted and so that process q can receive the correct message.
------------------------------------------------------------------------------

3. (7 points)
A corruption burst is called "uniform" if the corrupted bits in the burst
are the 1-st bit, the 6-th bit, the 11-th bit, the 16-bit, the 21-th bit, the
26-th bit, and so on till the last bit in the burst. Assume that our corruption
detection protocol (in Section 8.1) is used to detect corruption in a block
that consists of m*n data bits followed by n parity bits where m=15 and n=10. 
What is the length of the longest uniform corruption burst that can be detected
in this case. Briefly explain your answer.

Solution:

The length of the longest uniform corruption burst that can be
detected in this case is (m*n)+1=151, i.e., all the bits in the
1st and 6th column are corrupted except the 6th parity bit.
-------------------------------------------------------------------------------
 

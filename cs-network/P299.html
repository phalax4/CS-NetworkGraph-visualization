<base href="https://www.cs.utexas.edu/~byoung/cs429/all-tests-study-guide.html">
<HTML>
<HEAD>
<TITLE>CS 429 Fall 2017 for Tests 1 and 2</TITLE>
<META name="KeyWords" content="CS 429 Fall 2017">

</HEAD>
<BODY>

<b>The study guides for Test 2 is farther down the page.</b><P>

    <!-- <b>The study guides for Tests 2, 3, and the final are farther down the page.</b><P> -->

This is a study guide for Exams 1 and 2 for CS429.  Each test will
cover material that we have discussed in class, labs, and assigned
readings.  Each test is closed book / closed notes, but you may bring
one <i>handwritten</i> 8 1/2 by 11 inch sheet of notes (both sides) to
the test, except for the final.  You may have two such sheets for the
final.

<H2>CS429 Test 1 Study Guide </H2>

<H3>Readings for Test 1</H3>

You are expected to have read the following sections of Bryant and
O'Hallaron:  chapter 1, chapter 2, section 4.2.<P>

Also review all of the slidesets (including the one on C) through
slideset 5.

<H3>Slideset 1: Introduction</H3>

<OL TYPE="1" START="1">
<li> Understand why ints are not integers and floats are not reals.
<li> What is the value of knowing assembly language?
<LI> Why does a programmer need to consider memory issues?
</ol>

<H3>Slideset C: Basic C</H3>

<OL TYPE="1" START="1">
<li> Know how to write simple programs in C.
<li> Understand the basic C data types. 
<li> Understand at least: program structure, assignments, casting, if,
  while, for, function calls, basic I/O, arithmetic and logical operators. 
<li> Understand the #include and #define directives.
<li> Know how to access and use command line arguments?
<li> How do you compile a program using gcc?  
<li> How can you name the output file?  What if you don't name it?
<li> How can you get the assembler output?
<li> How do you run your compiled program?
</ol>

<H3>Slideset 2: Bits and Bytes</H3>

<ol>
<li> Understand the idea of representing information as bits:
  integers, reals, characters, instructions.
<li> Understand packaging of bits into bytes, words, long words, etc. 
<li> Know what it means to say that memory is a byte-addressable array.
<li> Understand the distinction between big-endian and little-endian,
  and how to represent data in either format.
<li> Understand unsigned and signed integers and their
  representations.
<li> Understand boolean and logical operations.
<li> Understand how finite sets can be represented by bit vectors.
</ol>


<H3>Slideset 3: Integers</H3>

<OL TYPE="1" START="1">
<li> Understand encodings of integers: unsigned and two's complement. 
<li> Know how to interpret a bit string as binary, decimal or
  hexadecimal number.
<li> Know how to cast between signed / unsigned and what it means.
<li> Be able to do simple arithmetic (addition, subtraction,
  multiplication, division) with signed or unsigned values.
<li> Understand the relation between shifting and multiplication /
  division.
<li> Understand sign extension.  
</ol>


<H3>Slideset 4: Floating Point</H3>

<OL TYPE="1" START="1">
<li> Understand the analogy of floating point to scientific notation.
<li> Understand the representation of (some) reals in floating point. 
<li> Be able to translate between decimal notion and FP 
<li> Understand the distinction between normalized and denormalized numbers.
<li> Understand the special values (infinities and NaNs).
<li> Be able to round using any of the four rounding modes.
<li> Know the default rounding mode.
<li> Understand why it makes sense that that one is the default.
</ol>

<H3>Slideset 5: Logic Design</H3>

<OL TYPE="1" START="1">
<li> Understand the electrical nature of bits in signals.
<li> Know the truth tables for simple logical functions: AND, OR, NOT,
  XOR. 
<li> Be able to construct truth tables for simple logical expressions.
<li> Know the symbols for the logic gates: AND, OR, NOT, XOR.
<li> Be able to read and understand a simple logic diagram composed of
  gates and wires. 
<li> Realize that it takes time for a signal to propogate through a
  circuit. 
<li> Understand the logical interpretation of such a diagram.
<li> Understand the notion of hierarchical design (composing simpler
  circuits to form more complicated circuits). 
<li> Be able to write HCL expressions corresponding to simple circuits.
<li> Understand the following circuits: bit equality, word equality,
  bit multiplexor, word multiplexor, 1-bit adder, 4-bit ALU.
<li> Know the difference between combinational and sequential circuits.
<li> Be able to follow the logic of simple state-holding devices:
  SR flip-flops, D latches, 
<li> Understand how latches are combined to form registers and
  register files.
<li> Understand clock signals and why circuits are clocked.
</ol>

 Don't worry about the algebraic structures: Groups, Rings,
  Algebras, etc.  I won't ask you about that stuff.  But you should
  know what the properties are (e.g., associativity, commutativity,
  distributivity) and whether they hold for various representations. 

<BR><br><HR><BR>

<H2>CS429 Test 2 Study Guide </H2>

<H3>What is Covered</H3>

Test 2 is cumulative but primarily covers slidesets 6-11. <P>

<H3>Readings for Test 2</H3>

You are expected to have read the following sections of Bryant and
O'Hallaron:  section 4.1 and chapter 3 (through section 3.9).<P>

<H3>Slideset 6: Instruction Set Architecture I</H3>

<OL TYPE="1" START="1">
<li> Understand what the ISA.
<li> How is it an abstraction layer?
<li> Understand the components of the Y86 processor state: registers,
  condition codes, PC, status, memory.
<li> Know the names of the registers and the special function of
  the stack pointer.
<li> Understand the idea of encoding instructions into bit strings.
<li> <i>Don't worry about memorizing any details of the Y86 encoding.</i>
<li> Understand the program stack and how it's used by Y86 programs.
<li> Given simple Y86 code, be able to explain what it does. 
<li> Understand how function calls and returns occur in Y86.
<li> How are arguments passed to functions and how is the function
  value returned?
<li> Understand the distinction between high level languages, assembly
  language and machine language.
<li> Understand abstractly what the compiler and assembler do.
<li> Know the function of assembler "directives" such as .pos, .quad,
  etc. 
<li> Understand the Y86 stack discipline for call and return. 
<li> Understand the different responsibilities of caller and callee in
  a procedure call.
<li> Be able to read and understand Y86 assembler examples. 
<!-- <li> Understand the pros and cons of CISC and RISC machines.
<li> Why did CISC "win" if RISC is technologically superior? -->
</ol>

<H3>Slideset 7: ISA II</H3>

<OL TYPE="1" START="1">
<li> Understand why x86 retains many arcane and obsolete features.
<li> <i> There is no need to know the sequence of x86 machines or
    their features.</i>
<!-- <LI> Know that Intel has competitors in their market. -->
<LI> Understand the difference in level of abstraction between C and
  assembly (data types, control statements).
<LI> What is an ISA and what purposes does one serve?
<LI> Understand the distinction between an architecture and an
  implementation, and what kinds of things fall into each. 
<LI> Know the basic steps in turning C into an executable image in
  memory. 
<LI> Understand the notion of disassembling. 
<LI> Understand that there are different formats for assembly (which
  generate the same machine code). 
<LI> Know the common x86 addressing modes.
<LI> Understand the x86 mov instruction format and semantics. 
<LI> Understand the meaning and uses of the C "*" and "&amp;"
  operators.
<LI> Know how to dereference pointers and create addresses. 
<LI> Be able to interpret x86 code at the level of the examples on the
  slides. 
<LI> Be able to execute (on paper) a simple program and explain the
  effect on the system state (registers, flags, etc.)
<LI> Understand the distinction between movq and leaq.
<LI> Know the basic arithmetic operations for x86. 
<LI> Know how to use leaq for basic arithmetic. 
</ol>

<H3>Slideset 8: ISA III</H3>

<OL TYPE="1" START="1">
<li> Understand the x86 flags, what they mean, and what they are used
  for. 
<li> Understand the cmp and test instructions.
<LI> Know the various jumps and under what conditions they happen. 
<LI> <i>It's not necessary to know the specific condition code expressions that
    correspond to the various jumps or sets.</i>
<LI> Understand the structure of the x86 registers (including the byte
  and word addressable portions).
<LI> Understand how the following C constructs get compiled (if,
  if-else, do-while, while, for, switch).
<LI> Know what a jump table is and how it can be used in compiling a
  switch. 
<li> Understand under what conditions a switch might be compiled into
  if-else statements, jump tables, or something else.
<LI> Know about labels and goto's in C.
</ol>

<H3>Slideset 9: ISA IV</H3>

<OL TYPE="1" START="1">
<li> Understand the structure of the x86 (IA32) stack and how it's
  used. 
<LI> Know how push and pop work and what they're used for. 
<li> Understand the procedure call stack discipline (setup and tear
  down of stack frames, saving and restoring registers, argument
  passing, return address).
<LI> Understand the role of %rsp.
<LI> Be able to step through a procedure call and return.
<!-- <LI> Understand the distinction between values and pointers on the stack.  -->
<LI> Know the register saving conventions (caller saved and callee saved).
<LI> Know what's special about compiling recursive procedures. 
</ol>

<H3>Slideset 10: ISA V</H3>

<OL TYPE="1" START="1">
<li> Understand storage allocation for arrays. 
<LI> Be able to convert from array notation to pointer notation. 
<li> Be able to compute addresses and values of array elements.
<LI> Know about bounds checking in C.
<LI> Understand the guarantees of array allocation.
<LI> Understand nested arrays and multi-level arrays. How do they
  differ?  
<LI> Understand the assembly level computations for accessing arrays. 
<LI> Understand how C structures are implemented at the assembly
  level. 
</ol>

<H3>Slideset 11: ISA VI</H3>

<OL TYPE="1" START="1">
<li> Understand what it means to align data.
<LI> Why would a compiler align data?
<li> What are the basic alignment requirements?
<LI> Be able to compute alignment for structures.
<LI> How might you avoid wasted space due to alignment within structs?
<LI> Understand C unions and what they're good for. 
<LI> Be able to compute alignment for unions.
<LI> Review big and little endian representations of data.
</ol>

<BR><br><HR><BR>

</BODY>
</HTML>

<!-- <H2>CS429 Test 3 Study Guide </H2>

<H3>What is Covered</H3>

Test 3 is cumulative but primarily covers slidesets 12-25.  As usual,
the test is closed book / closed notes, but you may bring
one <i>handwritten</i> 8 1/2 by 11 inch sheet of notes (both sides) to
the test.<P>

<H3>Readings for Test 3</H3>

You are expected to have read the following sections of Bryant and
O'Hallaron: section 1.9.1, sections 4.3 to 4.5.10, chapter 6, sections
5.1 to 5.8, and 7.1 to 7.10.

<H3>Slideset 12: Datapath I</H3>

<OL TYPE="1" START="1">
<li> Understand the basic approach to designed a computer explained
  very briefly on the first few slides. 
<LI> Understand the stages of the sequential Y86 implementation, what
  each does, and why it's useful to consider such stages. 
<li> Understand on a conceptual level how instruction execution maps
  onto hardware. 
</ol>

<H3>Slideset 13: Datapath II</H3>

<OL TYPE="1" START="1">
<li> Be able to understand the type of flow diagrams in the slides
  (e.g., the Fetch Logic, etc.)
<LI> Be able to read and understand HCL descriptions describing
  signals in the architecture.
<li> Understand how signals propogate through the architecture.
<LI> Understand the limitations of a sequential (non-pipelined)
  implementation of any processor. 
<LI> Understand the notion of clocking. 
</ol>

<H3>Slideset 14: Pipeline I</H3>

<OL TYPE="1" START="1">
<li> Understand the concept of pipelining and why it's useful in
  processor implementation.
<LI> Understand the notion of sequential implementation as the
  execution model that a pipelined architecture must emulate.
<li> Understand pipeline stages, pipeline registers, latency and throughput. 
<LI> Be able to compute latency and throughput for sample pipelines
  (uniform and non-uniform).
<LI> Know the performance equation for pipelines. 
<LI> Understand the notion of cycles per instruction. 
<LI> How does pipelining impact performance?
<LI> What is a data dependency and how are they manifest?
<LI> What are data hazards?
<LI> What challenges do data hazards present for pipelined architectures?
</ol>

<H3>Slideset 15: Pipeline II</H3>

<OL TYPE="1" START="1">
<li> Understand the need for pipeline registers in the implemention.
<LI> Know the pipeline stages in the Y86 PIPE architecture and what
  they do.
<li> <i>You don't need to know all the signals or wires in PIPE.</i>
<LI> What are data hazards and control hazards?
<LI> What instruction types tend to produce data/control hazards?
<LI> Understand how data dependencies affect the pipeline.
<LI> Understand how inserting NOPs could help.
<LI> In what circumstances is predicting the PC a problem, and why? 
<LI> Understand the Y86 strategy for predicting the PC.
<LI> How do you recover from a PC misprediction?
<LI> What are the options for dealing with hazards?
<LI> What is stalling and how is it implemented?
<LI> What is a bubble and how is it implemented?
</ol>

<H3>Slideset 16: Pipeline III</H3>

<OL TYPE="1" START="1">
<li> What does data forwarding accomplish?
<LI> What are the limitations of forwarding?
<li> What is a load/use hazard?
<li> Understand the idea of performance analysis with pipelining.
<LI> Understand the factors that go into computing CPI.
<li> Why doesn't an N-stage pipeline typically speed up throughput by
  a factor of N?
</ol>

<h3>There was no Slideset 17.</H3>

<H3>Slideset 18: Storage Technologies</H3>

<OL TYPE="1" START="1">
<li> Understand the notions or RAM and ROM.
<LI> Understand DRAM and SRAM and their relative characteristics.
<li> How is DRAM accessed?
<LI> How are memory modules constructed from DRAM?
<LI> Understand volatile vs. non-volatile memories.
<LI> Understand what a bus does in a system and how one is accessed.
<LI> Understand how rotating disks are constructed and accessed.
<LI> Know how to compute disk capacity.
<LI> What are the components of disk access and their relative 
  significance? 
<LI> How do disks compare to DRAM and SRAM?
<LI> What do logical disk blocks accomplish?
<LI> Understand the basics of solid state disks and how they compare
  to other technologies.
<LI> Understand the CPU-Memory gap and its implications.
</ol>

<H3>Slideset 19: Cache I</H3>

<OL TYPE="1" START="1">
<li> Understand the importance of locality in a program.
<LI> Know the difference between spacial and temporal locality and
  how a program might manifest either.
<li> Be able to recognize good/bad locality in a program.
<LI> What does stride-k behavior mean?
<LI> Understand the basic idea of a memory hierarchy.
<LI> What typically changes as you go up/down the hierarchy?
<LI> Understand what caching means and why it's used.
<LI> Understand: cache hit, cache miss, victim, replacement strategy,
  placement strategy, cold miss, conflict miss, capacity miss.
</ol>

<H3>Slideset 20: Cache II</H3>

<OL TYPE="1" START="1">
<li> Understand the fundamentals of organizing a cache memory: sets,
  lines, blocks, tags, valid and dirty bits.
<LI> Understand how a cache is accessed given an address.
<LI> Given parameters of a cache, be able to compute hits and misses
  from sample input.
<li> Understand direct-mapped vs. set associative caches. 
<LI> Understand write-back and write-through. 
<LI> Understand write-allocate and no-write-allocate. 
<LI> What factors affect average memory access time (AMAT)?
<LI> How can a programmer improve performance by writing
  "cache-friendly" code?
</ol>

<H3>Slideset 21: Optimization I</H3>

<OL TYPE="1" START="1">
<li> What are the strengths and limitations of optimizing compilers in
  improving program performance?
<LI> Understand code motion and when it's useful.
<li> What is reduction in strength and when is it useful?
<LI> How can the programmer influence the compiler to favor registers over memory?
<LI> Why is CPE a more useful measure of efficiency than absolute time?
<LI> What is loop unrolling and how is it useful?
<LI> Why is a procedure call often considered an "optimization blocker"?
<LI> Read and understand the Vector ADT example as an exemplar
  of hand optimization techniques.
<LI> What is memory aliasing and why is it considered an optimization blocker?
<LI> Understand the notion of common subexpressions and their role in
  optimization. 
<LI> How is profiling used in code optimization?  What does one look
  for when profiling?
<LI> What are the limitations of profiling?
</ol>

<H3>Slideset 22: Optimization II</H3>

We actually did very little from this slideset.  The fundamental ideas
are in slideset 21.
<OL TYPE="1" START="1">
<li> Understand the notions of miss rate, hit rate, and miss penalty.
<LI> Understand the basic strategy of writing "cache-friendly code."
</ol>

<H3>Slideset 23: Amdahl's Law</H3>

<OL TYPE="1" START="1">
<li> Understand what Amdahl's Law is and why it's important.
<li> Know the formula for computing speedup and new execution time in
  the context of a partial system optimization.
<li> Understand how to use Amdahl's Law as a planning tool during
  optimization.
</ol>

<H3>Slideset 24: Linking I</H3>

<OL TYPE="1" START="1">
<li> What is a compiler driver and why is it useful?
<li> Understand how the preprocessor, compiler, assembler, and linker
  act together.
<LI> What is the basic problem solved by linking?
<li> What types of symbols need to be linked?
<LI> Understand the need for label resolution and basically how that
  occurs. 

<H3>Slideset 25: Linking II</H3>

<OL TYPE="1" START="1"> 
<li> Understand the distinction between a symbol definition and reference.
<li> Understand what problem external references pose and how (in
  general) it's resolved.
<LI> What are strong and weak symbols and what problem is being addressed?
<LI> What are the rules in C for resolving strong/weak conflicts?
</ol>

<H2>CS429 Final Exam Study Guide </H2>

<H3>What is Covered</H3>

The final exam is cumulative and covers slidesets 1-24, except 17.  As
usual, the test is closed book / closed notes, but you may bring
two <i>handwritten</i> 8 1/2 by 11 inch sheets of notes (both sides)
to the test.<P>

</BODY>
</HTML>

 -->

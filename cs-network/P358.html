<base href="http://www.cs.utexas.edu/users/novak/cs375final.html">
<HTML>
<!--  cs375final.html          G. Novak           04 Aug 17    -->
<!--    -->
<HEAD>
  <TITLE>CS 375, Compilers: Study Guide for Final Exam </TITLE>
</HEAD>
<BODY>

<H2>CS 375, Compilers: Study Guide for Final Exam</H2>

<H3>Date: Monday, August 14, 7-10 PM in GDC 1.304
<!--  <A href="http://facilitiesservices.utexas.edu/buildings/UTM/0500">UTC 3.122</A> -->
</H3>
<P>


<H3> Material on the 
<A href="http://www.cs.utexas.edu/users/novak/cs375midterm.html">
Midterm Study Guide</A> is included on the final.</H3>

<H3> Reading:</H3> Aho, Lam, Sethi, and Ullman, <I> Compilers: Principles,
Techniques, and Tools,</I>
Chapters 7 through 9.

<H3> Material covered in class:</H3>
<UL>

<LI> Topics in parsing programming language constructs:  current status
variable (last thing seen was start of expression, operand, operator);
type coercion; conversion of names with constant
compile-time values to constants; intermediate code for 
non-arithmetic statements.

<LI> Array references: methods for storing arrays (row-major order,
column-major order); effect of array order and loop order on efficiency;
computation of effective address (formula); why
optimization of array references is important.

<LI> Record structure declarations and references: what information is
stored in symbol table from declaration; generation of intermediate code for
references to records; references using pointers; records with variant parts.

<LI> Type systems, type checking.  Failure of type checking due to aliasing,
variant records, pointer arithmetic.

<LI> Intermediate representations: assembly language, machine language,
reverse Polish, quadruples, triples, trees:  advantages and disadvantages
of each, comparisons.  Be able to produce any of these forms as output
of a shift-reduce parser.

<LI> Link editor: functions it performs: find needed code modules,
allocate storage to modules, relocate the code.

<LI> Code generation:  absolute code, relocatable code, assembly language
(advantages, disadvantages); generation of executable code, calls,
interpreted code; how to generate code from trees; ways to improve
generated code.

<LI> Runtime storage organization:

<UL>
    <LI> Data area, base address, offset, location counter; representation
of addresses in relocatable binary output and how the link editor handles them.

    <LI> Static allocation:  program relocation.

      <!-- Templates, dope vectors, hashed sparse matrices, strings  -->

     <LI> Storage management for recursive languages:
stack frame, stack pointer; procedure entry and exit;
local and global variables and how they correspond to symbol table
organization.

<LI> Records; dynamic storage management: heap, storage leak,
garbage collection (requires a strong type system).
<!--  by boundary tag method:  adv, disadv. -->
</UL>

<LI> Formal, actual, implicit parameters; call by reference, value,
pointer.  Macros.

<LI> Optimization:  economic considerations; constant folding,
partial evaluation, inlining,
peephole optimization, eliminating dead code, common subexpression removal,
moving non-changing code out of loops, reduction in strength,
optimization of subscript expressions, loop
unrolling; basic blocks:  definition; relation to program flow graph;
be able to mark the blocks in a sequence of code.
Bit vectors: referenced, defined, computed, killed, available, busy;
graphs, transitive closure, dominators; intervals; global program analysis;
graph coloring for register assignment.

<LI> OOP: representation of an object; process of message sending
(method call);
efficiency issues, compiler optimization, just-in-time compilation.

<LI> Hardware support: register windows, memory prefetching, postincrement.
</UL>

<H3>Vocabulary:</H3>
<TABLE>
<TR><TD>
absolute code   </TD><TD>
activation record  </TD><TD>
actual parameter  </TD></TR>
<TR><TD>adjacency matrix  </TD><TD>
aliasing   </TD><TD>
antisymmetric </TD></TR>
<TR><TD>automatic programming  </TD><TD>
available   </TD><TD>
backpatching  </TD></TR>
<TR><TD>basic block   </TD><TD>
bit vector  </TD><TD>
Boolean matrix  </TD></TR>
<TR><TD>BSS storage </TD><TD>
busy   </TD><TD>
cache prefetch </TD></TR>
<TR><TD>call by name   </TD><TD>
call by reference   </TD><TD>
call by value  </TD></TR>
<TR><TD>canonical form   </TD><TD>
Cartesian product  </TD><TD>
class  </TD></TR>
<TR><TD>code motion   </TD><TD>
column-major order  </TD><TD>
computed   </TD></TR>
<TR><TD>condition code register   </TD><TD>
constant folding </TD><TD>
control flow analysis  </TD></TR>
<TR><TD>dangling reference   </TD><TD>
data flow analysis  </TD><TD>
dead code   </TD></TR>
<TR><TD>defined   </TD><TD>
definition-use chain  </TD><TD>
dereference a pointer   </TD></TR>
<TR><TD>  </TD><TD>
dominator   </TD><TD>
dynamic  </TD></TR>
<TR><TD>dynamic memory  </TD><TD>
dynamic type checking  </TD><TD>
epilogue  </TD></TR>
<TR><TD>formal parameter  </TD><TD>
forward reference   </TD><TD>
fragmentation   </TD></TR>
<TR><TD>garbage </TD><TD>
garbage collection  </TD><TD>
global optimization  </TD></TR>
<TR><TD>graph  </TD><TD>
graph coloring   </TD><TD>
heap  </TD></TR>
<TR><TD>implicit parameter  </TD><TD>
induction variable   </TD><TD>
inherit </TD></TR>
<TR><TD>inherited attribute   </TD><TD>
inlining  </TD><TD>
instance  </TD></TR>
<TR><TD>instance variable  </TD><TD>
interpreted code  </TD><TD>
interval   </TD></TR>
<TR><TD>keyword   </TD><TD>
killed  </TD><TD></TR>
<TR><TD>lexical scoping   </TD><TD>
link editor  </TD><TD>
live variable   </TD></TR>
<TR><TD>loader   </TD><TD>
local optimization  </TD><TD>
location counter   </TD></TR>
<TR><TD>loop unrolling  </TD><TD>
macro  </TD><TD>
mark-and-sweep  </TD></TR>
<TR><TD>materialization   </TD><TD>
memory hierarchy </TD><TD>
memory leak   </TD></TR>
<TR><TD>message  </TD><TD>
method </TD><TD>
multiple inheritance </TD></TR>
<TR><TD>name equivalence   </TD><TD>
nonvolatile register   </TD><TD>
object </TD></TR>
<TR><TD>object-oriented programming  </TD><TD>
overloading </TD><TD>Pareto distribution</TD></TR>
<TD>
partial evaluation   </TD><TD>
partial order </TD></TR>
<TR><TD>partition  </TD><TD>
peephole optimization   </TD><TD>
polymorphic function  </TD></TR>
<TR><TD>postamble  </TD><TD>
postincrement  </TD><TD>
preamble </TD></TR>
<TR><TD>predictive parsing   </TD><TD>
prologue  </TD><TD>
quadruples  </TD></TR>
<TR><TD>reduction in strength   </TD><TD>
referenced  </TD><TD>
reflexive transitive closure   </TD></TR>
<TR><TD>relation   </TD><TD>
relocatable code  </TD><TD>
relocation   </TD></TR>
<TR><TD>restore registers  </TD><TD>
return address </TD><TD>
reverse Polish   </TD></TR>
<TR><TD>RISC   </TD><TD>
row-major order  </TD><TD>
save registers  </TD></TR>
<TR><TD>selector  </TD><TD>
send a message </TD><TD>
sound type system  </TD></TR>
<TR><TD>spill code  </TD><TD>
stack frame  </TD><TD>
stack pointer </TD></TR>
<TR><TD>static  </TD><TD>
static analysis  </TD><TD>
static type checking  </TD></TR>
<TR><TD>strong typing   </TD><TD>
structural equivalence  </TD><TD>
superclass  </TD></TR>
<TR><TD>superscalar   </TD><TD>
synthesized attribute  </TD><TD>
three-address code   </TD></TR>
<TR><TD>three-address machine  </TD><TD>
transitive closure   </TD><TD>
triples   </TD></TR>
<TR><TD>two-address code  </TD><TD>
two-address machine   </TD><TD>
type coercion   </TD></TR>
<TR><TD>type hierarchy </TD><TD>
type signature  </TD><TD>
union type   </TD></TR>
<TR><TD>unreachable code  </TD><TD>
volatile register    </TD></TR>
</TABLE>


</BODY>

</HTML>

<base href="http://www.cs.utexas.edu/~gouda/cs356summer09/midterm3/">
-------------------------------------------------------------------------------
Mohamed G. Gouda                                                CS 356
Summer 2009                                                 	Midterm 3
------------------------------------------------------------------------------
Open Book                                                       75 minutes
------------------------------------------------------------------------------
1. (10 points)
Consider a network p[i : 0..n-1] that consists of one cycle, where each process
p[i] has exactly two neighbors p[i -n 1] and p[i +n 1]. The processes in this
network generate data(d) messages and proceed to route each generated message, 
without using routing tables, to the ultimate destination, process p[d], of 
this message. Process p[i : 0..n-1] in this network can be specified as 
follows:

process p[i : 0..n-1]
inp N  :  set{i -n 1, i +n 1},
    up :  array[N] of boolean
var d  :  0..n-1
par g  :  N
begin
    true	          -->  d := any; RTMSG
[]  rcv data(d) from p[g] -->	
	if i = d --> {arrived} skip
	[] i != d ^ g = i -n 1 ^  up[i +n 1] --> send data(d) to p[i +n 1]
	[] i != d ^ g = i -n 1 ^ ~up[i +n 1] --> {nonreachable dst} skip
	[] i != d ^ g = i +n 1 ^  up[i -n 1] --> send data(d) to p[i -n 1]
	[] i != d ^ g = i +n 1 ^ ~up[i -n 1] --> {nonreachable dst} skip
end

Specify statement RTMSG in the first action of process p[i : 0..n-1].

Solution:

RTMSG:
if i=d  -> {arrived} skip
[] i!=d ^ (~up[i -n 1] ^ ~up[i +n 1]) -> skip
[] i!=d ^ ( up[i -n 1] ^ ~up[i +n 1]) -> send data(d) to p[i -n 1]
[] i!=d ^ (~up[i -n 1] ^  up[i +n 1]) -> send data(d) to p[i +n 1]
[] i!=d ^ ( up[i -n 1] ^  up[i +n 1]) -> 
          if i=d                -> {impossible} skip
          [] i>d ^ (i-d) >= n/2 -> send data(d) to p[i -n 1]
          [] i>d ^ (i-d) <  n/2 -> send data(d) to p[i +n 1]
          [] i<d ^ (d-i) >= n/2 -> send data(d) to p[i -n 1]
          [] i<d ^ (d-i) <  n/2 -> send data(d) to p[i +n 1]
          fi
fi
-------------------------------------------------------------------------------
2. (10 points)
Consider a network p[i : 0..n-1], where n is at least 2, that consists of one 
line, where process p[0] has only one neighbor p[1], process p[n-1] has only 
one neighbor p[n-2], and each other process p[i : 1..n-2] has exactly two 
neighbors: p[i-1] and p[i+1]. Each process p[i : 1..n-2] has two inputs, named
left and right.
	left is the smallest index, that is at most i, such that process p[i] 
	can reach p[left], i.e. all the edges between p[i] and p[left] in the 
	network topology are labeled up. 

	right is the largest index, that is at least i, such that process p[i]
	can reach p[right], i.e. all the edges between p[i] and p[right] in the
	network topology are labeled up.
The processes in this network generate data(d) messages and proceed to route 
each generated message, using the inputs left and right, to the ultimate 
destination, process p[d], of this message.

Process p[i : 1..n-2] can be specified as follows:

process p[i : 1..n-2]
inp N    :  set{i -n 1, i +n 1},
    up   :  array[N] of boolean,
    left :  0..i,
    right:  i..n-1
var d  :  0..n-1
par g  :  N
begin
    true	          -->  d := any; RTMSG
[]  rcv data(d) from p[g] -->  RTMSG	
end

Specify statement RTMSG in the two actions of process p[i : 1..n-2].

Solution:

RTMSG:
if d=i -> {arrived} skip
[] d!=i ^ (d<left v d>right)   -> {nonreachable dst} skip
[] d<i  ^ (d>=left ^ d<=right) ^ ~up[i-1] -> {nonreachable dst} skip
[] d<i  ^ (d>=left ^ d<=right) ^ up[i-1]  -> send data(d) to p[left]
[] d>i  ^ (d>=left ^ d<=right) ^ ~up[i+1] -> {nonreachable dst} skip
[] d>i  ^ (d>=left ^ d<=right) ^ ~up[i+1] -> send data(d) to p[right]
fi
------------------------------------------------------------------------------

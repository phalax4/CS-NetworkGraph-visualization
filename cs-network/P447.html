<base href="https://www.cs.utexas.edu/users/novak/cs375midterm.html">
<HTML>
<!--  cs375midterm.html          G. Novak         25 Oct 17      -->
<!--    -->
<HEAD>
  <TITLE>CS 375, Compilers: Study Guide for Midterm Exam </TITLE>
</HEAD>
<BODY>

<H2>CS 375, Compilers: Study Guide for Midterm Exam</H2>

<H3>Date: Tuesday, October 31, 2017, in class.</H3>
<P>

<H3> Reading:</H3> Aho, Lam, Sethi, and Ullman, <I>Compilers: Principles,
Techniques, and Tools</I>,
Chapters 1; 3 through 3.5; 4 through p. 220,
4.5, 4.6.3, 4.9; 5.1, 5.3; 6 through 6.5, 2.7.  Class lecture notes.

<H3> Material covered in class:</H3>
<UL>

<LI> Major phases of a compiler; what the phases do; data flow between
phases.

<LI> Formal definition of a grammar; chart about grammar classes.

<LI> Regular languages: grammar definitions, uses; local ambiguity:
examples, ways to handle.
Relationship of finite automata and regular grammars; linear nature of
a derivation from a regular grammar.

<LI> Regular expressions:  definition; be able to construct a regular 
expression for a language, or to construct the language denoted by
a regular expression.  Relation between regular expressions and finite
automata; automatic construction of finite automata from regular
expressions.

<LI> Lexical analyzer:  what constructs are parsed; type of
grammar used; need for speed.  <tt>lex</tt>.

<LI> Context-free languages: grammar definition, memory needed
for parsing.  Notations for defining the syntax of a language:  BNF,
Pascal-style transition diagrams.  Ambiguous grammars vs. unambiguous
grammars.  Augmented transition network; Yacc.  What kinds of language
constructs are context-free?

<LI> Derivation from a context-free grammar: relationship to parse tree,
notations for a derivation, definition of a language in terms of
derivations.

<LI> Operator precedence grammar and parser:  definitions; precedence
numbers, associativity.  How operator precedence parser works (be able
to work an example).

<LI> Top-down parsing:  definition; why backup may be required;
for what kinds of languages does it work well; recursive descent
parser; problems with left recursion; left factoring; implementation
of top-down parser by a recursive program: be able to write a procedure
for a construct such as an IF statement.

<LI> Shift-reduce parser:  use of stack; four actions of shift-reduce parser;
relationship to canonical derivation; how parse tree is constructed
using shift-reduce parser.

<LI> Symbol tables:  methods of organization; speed, advantages, 
disadvantages of each; comparisons; be able to select a method for
a particular application.  Search is more frequent than insertion.
Symbol tables
for block-structured languages.  What things are put in symbol tables?
Examples of symbols in a compiler.  Deletion
of symbols:  when it is needed; relation to table organization methods.
Methods of storing identifier names.  Use of indirection or auxiliary
table structures.

<LI> Data area and base-offset addressing; storage allocation algorithm;
allocation of data in records; word alignment and padding; variant records.

<LI> Address calculations for array references (know the formulas).
Address calculations for access to fields of a record; determining
types of accesses to parts of a structure.  Be able to calculate the
size of an array of records; be able to calculate the address offsets
for access to an array element and record field.

</UL>

<H3> Vocabulary</H3>

<TABLE>

<TR><TD>abstract syntax tree (AST)</TD>
<TD>accepting state </TD>
<TD>address alignment </TD></TR>
<TR><TD>alphabet  </TD>
<TD>ambiguity </TD>
<TD>ambiguous grammar </TD></TR>
<TR><TD>arity </TD>
<TD>associativity </TD>
<TD>augmented transition network (ATN)</TD></TR>
<TR><TD>AVL tree</TD>
<TD>base address </TD>
<TD>basic type </TD></TR>
<TR><TD>BNF </TD>
<TD>bottom-up parsing </TD>
<TD>cascading errors </TD></TR>
<TR><TD>cast</TD>
<TD>CKY parser</TD>
<TD>Chomsky hierarchy </TD></TR>
<TR><TD>code generation </TD>
<TD>collision </TD>
<TD>concatenation </TD></TR>
<TR><TD>context-free grammar  </TD>
<TD>data area  </TD>
<TD>declaration</TD></TR>
<TR><TD>derivation  </TD>
<TD>deterministic finite automaton </TD>
<TD>disambiguating rules </TD></TR>
<TR><TD>enumerated type </TD>
<TD>equivalent grammars </TD>
<TD>error production </TD></TR>
<TR><TD>finite automaton  </TD>
<TD>grammar </TD>
<TD>hash function </TD></TR>
<TR><TD>hash table </TD>
<TD>hash with buckets</TD>
<TD>infix </TD></TR>
<TR><TD>insertion </TD>
<TD>intermediate language </TD>
<TD>Kleene closure</TD></TR>
<TR><TD>language denoted by a grammar </TD>
<TD>left-associative  </TD>
<TD>left recursion </TD></TR>
<TR><TD>left factoring </TD>
<TD>leftmost derivation </TD>
<TD>lexeme  </TD></TR>
<TR><TD>lexer</TD>
<TD>lexical analysis  </TD></TR>
<TR><TD>significand </TD>
<TD>NaN </TD>
<TD>nondeterministic finite automaton </TD></TR>
<TR><TD>nonterminal </TD>
<TD>object language </TD>
<TD>observability</TD></TR>
<TR><TD>offset   </TD>
<TD>operand </TD>
<TD>operator </TD></TR>
<TR><TD>optimization  </TD>
<TD>overloading</TD>
<TD>padding</TD></TR>
<TR><TD>parse tree  </TD>
<TD>parsing </TD>
<TD>pass </TD></TR>
<TR><TD>postfix </TD>
<TD>precedence </TD>
<TD>prefix  </TD></TR>
<TR><TD>preorder </TD>
<TD>production  </TD>
<TD>recognizer </TD></TR>
<TR><TD>record</TD>
<TD>recursive descent </TD>
<TD>reduce-reduce conflict </TD></TR>
<TR><TD>reduction step </TD>
<TD>regular expression  </TD>
<TD>regular grammar </TD></TR>
<TR><TD>regular language  </TD>
<TD>rehash </TD>
<TD>reserved word </TD></TR>
<TR><TD>right-associative </TD>
<TD>scalar type </TD>
<TD>semantics </TD></TR>
<TR><TD>shift-reduce parser </TD>
<TD>shift-reduce conflict </TD>
<TD>SNaN</TD></TR>
<TR><TD>start symbol, S</TD>
<TD>storage allocation</TD></TR>
<TR><TD>string  </TD>
<TD>subrange </TD>
<TD>substring </TD></TR>
<TR><TD>suffix  </TD>
<TD>symbol table </TD>
<TD>syntax </TD></TR>
<TR><TD>syntax-directed translation </TD>
<TD>synthesized translation </TD>
<TD>terminal  </TD></TR>
<TR><TD>token </TD>
<TD>top-down parsing </TD>
<TD>type </TD></TR>
<TR>
<TD>type constructor </TD>
<TD>type lattice</TD></TR>
<TR><TD>variable </TD></TR>

</BODY>

</HTML>

<base href="https://www.cs.utexas.edu/users/novak/cs375contents.html">
<HTML>
<!--  cs375contents.html          G. Novak     26 Aug 16    -->
<HEAD>
<TITLE>CS 375: Compilers: Lecture Notes</TITLE>
</HEAD>

<BODY>
<H2>CS 375: Compilers: Lecture Notes</H2>
<HR>
<P>
Copyright &#169 Gordon S. Novak Jr.
<P>
Permission is granted for individuals to make copies of these notes
for personal use, or for instructors to make copies for classroom use.
<p>
<B>Note:</B> Some of these pages use math symbols such as: &forall; &exist; .
Microsoft Internet Explorer will not display the math symbols, but
<a href="http://www.mozilla.com">Firefox</a> will.
<P>
<a href="cs375index.html">Index</a><P>

<A href="cs3751.html">1. CS 375, Compilers: Class Notes</A><BR>
<A href="cs3752.html">2. </A><BR>
<A href="cs3753.html">3. Course Topics</A><BR>
<A href="cs3754.html">4. Pascal Test Program</A><BR>
<A href="cs3755.html">5. Introduction</A><BR>
<A href="cs3756.html">6. Machine Language</A><BR>
<A href="cs3757.html">7. Assembly Language</A><BR>
<A href="cs3758.html">8. High-Level Language</A><BR>
<A href="cs3759.html">9. Compilers</A><BR>
<A href="cs37510.html">10. Sequential Phases of a Compiler</A><BR>
<A href="cs37511.html">11. Data Flow through the Compiler</A><BR>
<A href="cs37512.html">12. Line Handler</A><BR>
<A href="cs37513.html">13. Lexical Analyzer</A><BR>
<A href="cs37514.html">14. Syntactic Analyzer</A><BR>
<A href="cs37515.html">15. Semantic Analysis</A><BR>
<A href="cs37516.html">16. Lexical Analysis</A><BR>
<A href="cs37517.html">17. Character Classes</A><BR>
<A href="cs37518.html">18. Implementation of Character Classes</A><BR>
<A href="cs37519.html">19. Hand-written Lexical Analyzer</A><BR>
<A href="cs37520.html">20. Example Lexical Analyzer</A><BR>
<A href="cs37521.html">21. Flowchart for Parsing Identifier</A><BR>
<A href="cs37522.html">22. Lexical Language Design</A><BR>
<A href="cs37523.html">23. Token Data Structure</A><BR>
<A href="cs37524.html">24. Example Token Data Structure</A><BR>
<A href="cs37525.html">25. Number Conversion</A><BR>
<A href="cs37526.html">26. Simple Number Scanner</A><BR>
<A href="cs37527.html">27. Lexical Analyzer Output</A><BR>
<A href="cs37528.html">28. Floating Point Numbers </A><BR>
<A href="cs37529.html">29. IEEE Floating Point Standard </A><BR>
<A href="cs37530.html">30. Floating Point Examples </A><BR>
<A href="cs37531.html">31. Errors</A><BR>
<A href="cs37532.html">32. Error Messages</A><BR>
<A href="cs37533.html">33. Formal Syntax</A><BR>
<A href="cs37534.html">34. Grammar</A><BR>
<A href="cs37535.html">35. Language Generation</A><BR>
<A href="cs37536.html">36. Parsing</A><BR>
<A href="cs37537.html">37. Ambiguity</A><BR>
<A href="cs37538.html">38. Notation</A><BR>
<A href="cs37539.html">39. Phrase Structure Grammar</A><BR>
<A href="cs37540.html">40. Chomsky Hierarchy</A><BR>
<A href="cs37541.html">41. Recognizing Automaton</A><BR>
<A href="cs37542.html">42. Chomsky Language Hierarchy</A><BR>
<A href="cs37543.html">43. Regular Languages</A><BR>
<A href="cs37544.html">44. Example Regular Language</A><BR>
<A href="cs37545.html">45. lex</A><BR>
<A href="cs37546.html">46. Regular Expressions</A><BR>
<A href="cs37547.html">47. Lex Specifications</A><BR>
<A href="cs37548.html">48. Sample lex Specification</A><BR>
<A href="cs37549.html">49. C for Lex Sample</A><BR>
<A href="cs37550.html">50. lex.yy.c</A><BR>
<A href="cs37551.html">51. Comments on Sample lex</A><BR>
<A href="cs37552.html">52. Translation Section</A><BR>
<A href="cs37553.html">53. Lex Conventions</A><BR>
<A href="cs37554.html">54. The Lookahead Operator</A><BR>
<A href="cs37555.html">55. Auxiliary Procedures</A><BR>
<A href="cs37556.html">56. Parser Overview</A><BR>
<A href="cs37557.html">57. Context Free Languages</A><BR>
<A href="cs37558.html">58. Context Sensitive Languages</A><BR>
<A href="cs37559.html">59. Derivations</A><BR>
<A href="cs37560.html">60. Language Generated by a Grammar</A><BR>
<A href="cs37561.html">61. Ambiguity and Left Recursion</A><BR>
<A href="cs37562.html">62. Parsing</A><BR>
<A href="cs37563.html">63. Top-down Parser</A><BR>
<A href="cs37564.html">64. Bottom-up Parsing</A><BR>
<A href="cs37565.html">65. Chart Parser</A><BR>
<A href="cs37566.html">66. Augmented Transition Network Grammars</A><BR>
<A href="cs37567.html">67. Augmented Transition Networks</A><BR>
<A href="cs37568.html">68. Context Free Parser</A><BR>
<A href="cs37569.html">69. Semantics Influences Parsing</A><BR>
<A href="cs37570.html">70. Arithmetic Expressions</A><BR>
<A href="cs37571.html">71. Example of Operator Precedence</A><BR>
<A href="cs37572.html">72. Operator Precedence</A><BR>
<A href="cs37573.html">73. Operator Precedence Parsing</A><BR>
<A href="cs37574.html">74. Operator Precedence Parser</A><BR>
<A href="cs37575.html">75. Examples</A><BR>
<A href="cs37576.html">76. Stack Handling in C</A><BR>
<A href="cs37577.html">77. Basic Routines</A><BR>
<A href="cs37578.html">78. </A><BR>
<A href="cs37579.html">79. Operator Precedence Parser</A><BR>
<A href="cs37580.html">80. </A><BR>
<A href="cs37581.html">81. Additional Considerations</A><BR>
<A href="cs37582.html">82. Recursive Descent Parser</A><BR>
<A href="cs37583.html">83. Bottom-up Table-driven (LR) Parsing</A><BR>
<A href="cs37584.html">84. The LR Parsing Algorithm</A><BR>
<A href="cs37585.html">85. Shift-Reduce Parser</A><BR>
<A href="cs37586.html">86. Example Parsing Table(Aho, Lam, Sethi, and</A><BR>
<A href="cs37587.html">87. A Parse of <TT> id * id + id</TT>(Aho, Lam, Sethi, and</A><BR>
<A href="cs37588.html">88. Synthesized Translation</A><BR>
<A href="cs37589.html">89. Using <TT> yacc</TT></A><BR>
<A href="cs37590.html">90. y.tab.c</A><BR>
<A href="cs37591.html">91. Yacc Specifications</A><BR>
<A href="cs37592.html">92. Example: Desk Calculator</A><BR>
<A href="cs37593.html">93. Yacc: Pascal Subset</A><BR>
<A href="cs37594.html">94. Auxiliary C Code </A><BR>
<A href="cs37595.html">95. Auxiliary C Code ... </A><BR>
<A href="cs37596.html">96.  Controllability and Observability</A><BR>
<A href="cs37597.html">97. Example </A><BR>
<A href="cs37598.html">98. Examples ...</A><BR>
<A href="cs37599.html">99. Examples ...</A><BR>
<A href="cs375100.html">100. Hints for <TT> yacc</TT></A><BR>
<A href="cs375101.html">101. File <TT> trivb.tree</TT></A><BR>
<A href="cs375102.html">102. The Semantic Actions</A><BR>
<A href="cs375103.html">103. Supporting C Routines</A><BR>
<A href="cs375104.html">104. Example</A><BR>
<A href="cs375105.html">105. Comments on the Example</A><BR>
<A href="cs375106.html">106. Parsing Action Conflicts</A><BR>
<A href="cs375107.html">107. Resolving Shift/Reduce Conflicts</A><BR>
<A href="cs375108.html">108. Error Productions</A><BR>
<A href="cs375109.html">109. Error Handling</A><BR>
<A href="cs375110.html">110. Parsing Techniques</A><BR>
<A href="cs375111.html">111. Looping Statements</A><BR>
<A href="cs375112.html">112. Symbol Table</A><BR>
<A href="cs375113.html">113. Symbol Table Organization</A><BR>
<A href="cs375114.html">114. Symbol Table Organizations</A><BR>
<A href="cs375115.html">115. Binary Tree Symbol Table</A><BR>
<A href="cs375116.html">116. AVL Trees</A><BR>
<A href="cs375117.html">117. Hash Table</A><BR>
<A href="cs375118.html">118. Hash Functions</A><BR>
<A href="cs375119.html">119. Indexed Buckets</A><BR>
<A href="cs375120.html">120. Lexical Scoping</A><BR>
<A href="cs375121.html">121. Tree of Symbol Tables</A><BR>
<A href="cs375122.html">122. Stack Symbol Table</A><BR>
<A href="cs375123.html">123. Use of Symbol Table</A><BR>
<A href="cs375124.html">124. Symbol Table Entry</A><BR>
<A href="cs375125.html">125. Kinds of Symbols</A><BR>
<A href="cs375126.html">126. Kinds of Symbols ...</A><BR>
<A href="cs375127.html">127. Looking up ID in Symbol Table</A><BR>
<A href="cs375128.html">128. Variable Declarations</A><BR>
<A href="cs375129.html">129. Identifier List etc.</A><BR>
<A href="cs375130.html">130. Data Addressing</A><BR>
<A href="cs375131.html">131. Storage Allocation</A><BR>
<A href="cs375132.html">132. Alignment and Padding</A><BR>
<A href="cs375133.html">133. Installing Variables in Symbol Table</A><BR>
<A href="cs375134.html">134. Record Declarations</A><BR>
<A href="cs375135.html">135. Symbol Table Structures for Record</A><BR>
<A href="cs375136.html">136. Array Declarations</A><BR>
<A href="cs375137.html">137. Symbol Table Structures for Array</A><BR>
<A href="cs375138.html">138. Type Checking, Coercion, and Inference</A><BR>
<A href="cs375139.html">139. Structure References</A><BR>
<A href="cs375140.html">140. Structure References....</A><BR>
<A href="cs375141.html">141. Record References</A><BR>
<A href="cs375142.html">142. Array References</A><BR>
<A href="cs375143.html">143. Array References in Pascal</A><BR>
<A href="cs375144.html">144. Does Array Order Matter?</A><BR>
<A href="cs375145.html">145. Example of Structure Declaration</A><BR>
<A href="cs375146.html">146. Example of Structure Reference</A><BR>
<A href="cs375147.html">147. Pointer Reference</A><BR>
<A href="cs375148.html">148. Types as Tree Structures</A><BR>
<A href="cs375149.html">149. Dynamic Type Checking</A><BR>
<A href="cs375150.html">150. Static Type Checking</A><BR>
<A href="cs375151.html">151. Strong Typing</A><BR>
<A href="cs375152.html">152. Type Equivalence</A><BR>
<A href="cs375153.html">153. Type Signatures</A><BR>
<A href="cs375154.html">154. Polymorphic Procedures</A><BR>
<A href="cs375155.html">155. Table for Labels</A><BR>
<A href="cs375156.html">156. Intermediate Code</A><BR>
<A href="cs375157.html">157. Trees</A><BR>
<A href="cs375158.html">158. Quadruples</A><BR>
<A href="cs375159.html">159. Triples</A><BR>
<A href="cs375160.html">160. Reverse Polish Notation</A><BR>
<A href="cs375161.html">161. Trees and Reverse Polish</A><BR>
<A href="cs375162.html">162. Converting a Tree to RPN</A><BR>
<A href="cs375163.html">163. Executing Reverse Polish</A><BR>
<A href="cs375164.html">164. Executing RPN</A><BR>
<A href="cs375165.html">165. RPN as Intermediate Code</A><BR>
<A href="cs375166.html">166. Code Generation</A><BR>
<A href="cs375167.html">167. Loading Process</A><BR>
<A href="cs375168.html">168. Absolute File</A><BR>
<A href="cs375169.html">169. Initializing BSS Storage</A><BR>
<A href="cs375170.html">170. Banked Memory</A><BR>
<A href="cs375171.html">171. Location Counter</A><BR>
<A href="cs375172.html">172. Example of Assembly Listing</A><BR>
<A href="cs375173.html">173. Backpatching</A><BR>
<A href="cs375174.html">174. Link Editing Process</A><BR>
<A href="cs375175.html">175. Relocatable Code</A><BR>
<A href="cs375176.html">176. Finding Relocatable Modules</A><BR>
<A href="cs375177.html">177. Assigning Absolute Addresses</A><BR>
<A href="cs375178.html">178. Absolute Addresses</A><BR>
<A href="cs375179.html">179. Link Editor</A><BR>
<A href="cs375180.html">180. Form of Relocatable Code</A><BR>
<A href="cs375181.html">181. Static Allocation</A><BR>
<A href="cs375182.html">182. Dynamically Linked Library</A><BR>
<A href="cs375183.html">183. Run-Time Support</A><BR>
<A href="cs375184.html">184. Operations by Subroutine</A><BR>
<A href="cs375185.html">185. Special Subroutines</A><BR>
<A href="cs375186.html">186. Memory Management</A><BR>
<A href="cs375187.html">187. Returning Memory</A><BR>
<A href="cs375188.html">188. Heap Memory Management</A><BR>
<A href="cs375189.html">189. Garbage Collection</A><BR>
<A href="cs375190.html">190. Garbage Collection</A><BR>
<A href="cs375191.html">191. Mark-And-Sweep Garbage Collection</A><BR>
<A href="cs375192.html">192. Mark-and-Sweep ...</A><BR>
<A href="cs375193.html">193. Copying Garbage Collection</A><BR>
<A href="cs375194.html">194. Reference Counting</A><BR>
<A href="cs375195.html">195. Reference Counting...</A><BR>
<A href="cs375196.html">196. Garbage Collection Is Expensive</A><BR>
<A href="cs375197.html">197. Compiled Procedure</A><BR>
<A href="cs375198.html">198. Subroutine Call Is Expensive</A><BR>
<A href="cs375199.html">199. Activations and Control Stack</A><BR>
<A href="cs375200.html">200. Environment</A><BR>
<A href="cs375201.html">201. Run-time Memory Organization</A><BR>
<A href="cs375202.html">202. Code Generation</A><BR>
<A href="cs375203.html">203. Code Generation</A><BR>
<A href="cs375204.html">204. Code Generation</A><BR>
<A href="cs375205.html">205. Running Generated Code</A><BR>
<A href="cs375206.html">206. Overview of Code Generation</A><BR>
<A href="cs375207.html">207. Code Generation for Statements</A><BR>
<A href="cs375208.html">208. Arithmetic Expressions</A><BR>
<A href="cs375209.html">209. Basic Expression Algorithm</A><BR>
<A href="cs375210.html">210. Trace of  Expression Algorithm</A><BR>
<A href="cs375211.html">211. Arithmetic Expression Algorithm</A><BR>
<A href="cs375212.html">212. Register Management</A><BR>
<A href="cs375213.html">213. Simple Register Allocation</A><BR>
<A href="cs375214.html">214. Heuristic for Expressions</A><BR>
<A href="cs375215.html">215. Improving Register Allocation</A><BR>
<A href="cs375216.html">216. Register Allocation</A><BR>
<A href="cs375217.html">217. Example of Code Generation</A><BR>
<A href="cs375218.html">218. Example (2)</A><BR>
<A href="cs375219.html">219. Example (3)</A><BR>
<A href="cs375220.html">220. Example (4)</A><BR>
<A href="cs375221.html">221. Reusing Register Contents</A><BR>
<A href="cs375222.html">222. Register Targeting</A><BR>
<A href="cs375223.html">223. x86 Processor</A><BR>
<A href="cs375224.html">224. Move (Load/Store) Instructions</A><BR>
<A href="cs375225.html">225. Kinds of Move Addressing</A><BR>
<A href="cs375226.html">226. Move with Calculated Address</A><BR>
<A href="cs375227.html">227. Literals</A><BR>
<A href="cs375228.html">228. Integer Arithmetic Instructions</A><BR>
<A href="cs375229.html">229. Compare and Jump</A><BR>
<A href="cs375230.html">230. Floating Point</A><BR>
<A href="cs375231.html">231. Intrinsic Functions</A><BR>
<A href="cs375232.html">232. Function Calls</A><BR>
<A href="cs375233.html">233. Volatile Registers</A><BR>
<A href="cs375234.html">234. Details of Function Call</A><BR>
<A href="cs375235.html">235. IF Statement Generation</A><BR>
<A href="cs375236.html">236. IF Statement Optimization</A><BR>
<A href="cs375237.html">237. Array References</A><BR>
<A href="cs375238.html">238. Easy Array References</A><BR>
<A href="cs375239.html">239. Better Array References</A><BR>
<A href="cs375240.html">240. Pointer References</A><BR>
<A href="cs375241.html">241. <TT> switch</TT> Statement</A><BR>
<A href="cs375242.html">242. <TT> switch</TT> Statement Compiled</A><BR>
<A href="cs375243.html">243. <TT> switch</TT> Statement Compiled <TT> -O</TT></A><BR>
<A href="cs375244.html">244. Table Lookup</A><BR>
<A href="cs375245.html">245. Table Lookup Compiled</A><BR>
<A href="cs375246.html">246. Table Lookup Compiled <TT> -O</TT></A><BR>
<A href="cs375247.html">247. Parameter Passing</A><BR>
<A href="cs375248.html">248. Macros</A><BR>
<A href="cs375249.html">249. In-line Compilation</A><BR>
<A href="cs375250.html">250. Optimization</A><BR>
<A href="cs375251.html">251. Correctness of Optimization</A><BR>
<A href="cs375252.html">252. Optional Optimization</A><BR>
<A href="cs375253.html">253. Local and Global Optimization</A><BR>
<A href="cs375254.html">254. Easy Optimization Techniques</A><BR>
<A href="cs375255.html">255. Constant Folding</A><BR>
<A href="cs375256.html">256. Peephole Optimization</A><BR>
<A href="cs375257.html">257. Loop Unrolling</A><BR>
<A href="cs375258.html">258. Partial Evaluation</A><BR>
<A href="cs375259.html">259. Partial Evaluation</A><BR>
<A href="cs375260.html">260. Example</A><BR>
<A href="cs375261.html">261. Simple Partial Evaluator</A><BR>
<A href="cs375262.html">262. Simple Partial Evaluator...</A><BR>
<A href="cs375263.html">263. Examples</A><BR>
<A href="cs375264.html">264. Examples</A><BR>
<A href="cs375265.html">265. Binding-Time Analysis</A><BR>
<A href="cs375266.html">266. Futamura Projections</A><BR>
<A href="cs375267.html">267. Interpreter</A><BR>
<A href="cs375268.html">268. Specialization</A><BR>
<A href="cs375269.html">269. Parameterized Programs</A><BR>
<A href="cs375270.html">270. Pitfalls of Partial Evaluation</A><BR>
<A href="cs375271.html">271. Pitfalls ...</A><BR>
<A href="cs375272.html">272. Program Analysis</A><BR>
<A href="cs375273.html">273. Basic Block</A><BR>
<A href="cs375274.html">274. Finding Basic Blocks</A><BR>
<A href="cs375275.html">275. Relations and Graphs</A><BR>
<A href="cs375276.html">276. Graph Notations</A><BR>
<A href="cs375277.html">277. Bit Vector Representations</A><BR>
<A href="cs375278.html">278. Boolean Matrix Representation of Graph</A><BR>
<A href="cs375279.html">279. Dominators</A><BR>
<A href="cs375280.html">280. Intervals</A><BR>
<A href="cs375281.html">281. Definition and Reference of Variables</A><BR>
<A href="cs375282.html">282. Data Flow Analysis for a Block</A><BR>
<A href="cs375283.html">283. Availability of Expressions</A><BR>
<A href="cs375284.html">284. Data Flow Analysis for an Interval</A><BR>
<A href="cs375285.html">285. Busy Variables</A><BR>
<A href="cs375286.html">286. Variable Uses and Register Assignment</A><BR>
<A href="cs375287.html">287. Register Allocation by Graph Coloring</A><BR>
<A href="cs375288.html">288. Overview of Global Optimization</A><BR>
<A href="cs375289.html">289. <TT> gcc</TT> Compiler Optimization Options</A><BR>
<A href="cs375290.html">290.  gcc Optimizations</A><BR>
<A href="cs375291.html">291. Loop Transformations</A><BR>
<A href="cs375292.html">292. Strip Mining</A><BR>
<A href="cs375293.html">293. Induction Variable Transformation</A><BR>
<A href="cs375294.html">294. Finite Differencing</A><BR>
<A href="cs375295.html">295. Example: Computing Squares</A><BR>
<A href="cs375296.html">296. General Case</A><BR>
<A href="cs375297.html">297. Finite Differencing for Set Operations</A><BR>
<A href="cs375298.html">298. Memoization</A><BR>
<A href="cs375299.html">299. Hardware Assistance</A><BR>
<A href="cs375300.html">300. PowerPC Features</A><BR>
<A href="cs375301.html">301. SPARC Features</A><BR>
<A href="cs375302.html">302. Hardware Trends</A><BR>
<A href="cs375303.html">303. Object-oriented Programming</A><BR>
<A href="cs375304.html">304. Access to Objects</A><BR>
<A href="cs375305.html">305. Domain Analysis</A><BR>
<A href="cs375306.html">306. Internal Implementation is Hidden</A><BR>
<A href="cs375307.html">307. Encapsulation with OOP</A><BR>
<A href="cs375308.html">308. Object-oriented Programming Terminology</A><BR>
<A href="cs375309.html">309. Terminology ...</A><BR>
<A href="cs375310.html">310. Implementation of Objects</A><BR>
<A href="cs375311.html">311. Are Basic Types Objects?</A><BR>
<A href="cs375312.html">312. Inheritance and Class Structure</A><BR>
<A href="cs375313.html">313. Message Sending</A><BR>
<A href="cs375314.html">314. Dynamic Method Lookup</A><BR>
<A href="cs375315.html">315. Static Method Lookup</A><BR>
<A href="cs375316.html">316. Multiple Inheritance</A><BR>
<A href="cs375317.html">317. Improving OOP Efficiency</A><BR>
<A href="cs375318.html">318. Smalltalk</A><BR>
<A href="cs375319.html">319. Smalltalk Code</A><BR>
<A href="cs375320.html">320. ThingLab</A><BR>
<A href="cs375321.html">321. ThingLab Examples</A><BR>
<A href="cs375322.html">322. Good Features of OOP</A><BR>
<A href="cs375323.html">323. Unfortunate Features of OOP</A><BR>
<A href="cs375324.html">324. Why OOP Is Not Enough</A><BR>
<A href="cs375325.html">325. Top Ten Lies About OOP</A><BR>
<A href="cs375326.html">326. Aspect-Oriented Programming</A><BR>
<A href="cs375327.html">327. Lisp</A><BR>
<A href="cs375328.html">328. History of Lisp</A><BR>
<A href="cs375329.html">329. Advantages of Lisp</A><BR>
<A href="cs375330.html">330. Lisp Interaction</A><BR>
<A href="cs375331.html">331. Function Definition</A><BR>
<A href="cs375332.html">332. List Structure</A><BR>
<A href="cs375333.html">333. Abstract Syntax Tree</A><BR>
<A href="cs375334.html">334. Binding Lists</A><BR>
<A href="cs375335.html">335. Substitution</A><BR>
<A href="cs375336.html">336. Copying and Substitution Functions</A><BR>
<A href="cs375337.html">337. Substitution in C</A><BR>
<A href="cs375338.html">338. Loop Unrolling</A><BR>
<A href="cs375339.html">339. Instantiating Design Patterns</A><BR>
<A href="cs375340.html">340. Pattern Matching</A><BR>
<A href="cs375341.html">341. Pattern Matching</A><BR>
<A href="cs375342.html">342. Transformation by Patterns</A><BR>
<A href="cs375343.html">343. Transformation Patterns</A><BR>
<A href="cs375344.html">344. Program Transformation using Lisp</A><BR>
<A href="cs375345.html">345. Dot Matching</A><BR>
<A href="cs375346.html">346. Looping Patterns</A><BR>
<A href="cs375347.html">347. Code Expansion by Looping Patterns</A><BR>
<A href="cs375348.html">348. More Complex Rules</A><BR>
<A href="cs375349.html">349. Multi-Level Patterns</A><BR>
<A href="cs375350.html">350. Use of Multi-Level Patterns</A><BR>
<A href="cs375351.html">351. Function Inlining</A><BR>
<A href="cs375352.html">352. Program Transformation</A><BR>
<A href="cs375353.html">353. Pattern Optimization Examples</A><BR>
<A href="cs375354.html">354. Examples ...</A><BR>
<A href="cs375355.html">355. Examples ...</A><BR>
<A href="cs375356.html">356. Examples ...</A><BR>
<A href="cs375357.html">357. Paul Graham:</A><BR>
<A href="cs375358.html">358. English</A><BR>
<A href="cs375359.html">359. Expression Trees to English (file</A><BR>
<A href="cs375360.html">360. Generating English</A><BR>
<A href="cs375361.html">361. Parsing English</A><BR>
<A href="cs375362.html">362. ATN in Lisp (file <TT> atn.lsp</TT>))</A><BR>
<A href="cs375363.html">363. Parsing Functions</A><BR>
<A href="cs375364.html">364. Grammar Compiler (file <TT> gramcom.lsp</TT>)</A><BR>
<A href="cs375365.html">365. Access to Database (file <TT> restgram.lsp</TT>)</A><BR>
<A href="cs375366.html">366. Restaurant Database Grammar</A><BR>
<A href="cs375367.html">367. Restaurant Queries</A><BR>
<A href="cs375368.html">368. Physics Problems (file <TT> physgram.lsp</TT>)</A><BR>
<A href="cs375369.html">369. Physics Queries</A><BR>

<HR>
<a href="cs375.html">CS 375</a><P>
</BODY>
</HTML>

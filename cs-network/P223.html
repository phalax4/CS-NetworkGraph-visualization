<base href="http://www.cs.utexas.edu/~gouda/cs356sp09/midterm3/">
------------------------------------------------------------------------------
Mohamed G. Gouda                                                CS 356
Spring 2009                                                 	Midterm 3
------------------------------------------------------------------------------
Open Book                                                       75 minutes
------------------------------------------------------------------------------

1. (7 points)
Simplify the Cumulative Acknowledgement protocol in Section 9.3 assuming that
the following three conditions hold:

	a. The exchanged (data or ack) messages between processes p 
   	   and q may be reordered but they are never corrupted nor 
	   lost.

	b. The size wr of the circular buffer "rcvd" in process q 
	   equals the window size w of the protocol.

	c. Whenever process q receives a data(j) message from process
	   p, q stores the message in its circular buffer "rcvd".

Specify process q in the simplified protocol.

Solution:

process q
const w
var nr, j : integer,                    {init. 0}
    rcvd  : array [0..w-1] of boolean,  {init. false}
    akn   : boolean                     {init. false}

begin
    rcv data(j) from p ->
        rcvd[j mod w] := true;
        do rcvd[nr mod w] ->
           {deliver data(nr)}
           rcvd[nr mod w],nr,akn := false,nr+1,true
        od
[]  akn -> akn := false; send akn(nr) to p    
end
-------------------------------------------------------------------------------

2. (7 points)
Assume that the protocol for maintaining global topology information in Section
11.3 is executing in a network of seven processes p[i : 0..6]. Also assume 
that, during the course of this execution, array net in process p[6] has the 
following values: 

	a. Each of the following elements in array net has the value 
	   true: 
		net[0, 1], net[1, 0], net[2, 3], net[3, 2]
		net[3, 4], net[4, 3], net[5, 6], net[6, 5]

	b. Each of the other elements in array net has the value false. 

Can process p[6] conclude, from these values in its array net, that the two
channels between processes p[2] and p[3] are both up? Explain your answer.

Solution:

No, process p[6] cannot conclude that the two channels between p[2]
and p[3] are both up because there is no up path from p[2] to p[6] or
from p[3] to p[6] and so p[6] cannot rcv the vp arrays of p[2] or
p[3].
-------------------------------------------------------------------------------

3. (6 points)
Modify the protocol for maintaining the local topology information in Section
11.2 as follows. Each process p[i : 0..n-1] in the protocol maintains an 
additional variable named "ngh" whose value is computed such that the 
following two conditions hold.

	a. If p[i] detects that it has one or more up neighbors at some 
	   instant, then the value of "ngh" in p[i] at that instant is 
	   the index of an up neighbor of p[i].

	b. If p[i] has no up neighbor at some instant, then the value of
   	   "ngh" in p[i] at that instant is the index of any neighbor of 
	   p[i].

Specify process p[i : 0..n-1] of this protocol.

Solution:

process p[i : 0..n-1]
inp N   : set {g | p[g] is a neighbor of p[i]}
var up  : array [N] of boolean,
    b   : 0..1,
    ngh : N
par g   : N

begin
    rcv chk(b) from p[g] ->
        if b=0 -> up[g] := false
        [] b=1 -> up[g] := true;
                  ngh   := g
        fi;
        send chk(1) to p[g]
[]  rcv error from p[g] -> skip
[]  timeout #ch.p[i].p[g]+#ch.p[g].p[i]=0 ->
            up[g] := false;
            if i<g  -> send chk(0) to p[g]
            [] i>=g -> skip
            fi
end   
-------------------------------------------------------------------------------
   
	       

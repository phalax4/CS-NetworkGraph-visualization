<base href="http://www.cs.utexas.edu/users/novak/asg-parse.html">
<HTML>
<!--  asg-parse.html          G. Novak           10 Aug 17    -->
<!--    -->
<HEAD>
  <TITLE>CS 375: Parser for Pascal</TITLE>
</HEAD>
<BODY>

<H2>CS 375: Parser for Pascal</H2>

<H3>Due: October 13, 2017:  <tt>trivb.pas</tt></H3>
<H3>Due: October 27, 2017:  <tt>graph1.pas</tt></H3>
<H3>Due: November 17, 2017:  <tt>graph1.pas</tt> and <tt>pasrec.pas</tt></H3>
<P>
Write a parser for the Pascal language (as defined by Jensen and Wirth, 2nd
ed.), producing intermediate code trees as output.
Your parser does <b>not</b> have to handle the following Pascal constructs:
<tt>with</tt> ... <tt>do</tt>, <tt>packed</tt>, <tt>file of</tt>,
<tt>set of</tt>, <tt>case</tt>;
in general, if your parser legitimately handles the test programs, it
will satisfy this assignment.
Use one of the lexical analyzers that you wrote in the first two assignments
as the lexical analyzer for this assignment.  You may modify the lexical
analyzer slightly if needed.
<P>
You may write the parser in one of the following ways (your choice):
<OL>
<LI> Write the parser using Yacc and C.

<LI> Write the parser as a program, in either Lisp or C, using
Recursive Descent and Operator Precedence parsing.
</OL>
<P>
The file <tt>pars1.y</tt> contains a small Yacc program for a Pascal subset;
the files <tt>pars1c.c</tt> and <tt>pars1.lsp</tt> contain equivalent programs
using operator precedence and recursive descent.
You may use one of these files as the starting point for your program.
<P>
Yacc is described in the textbook in Section 4.9 .  There is a <tt>man</tt>
description of <tt>yacc</tt> on-line.  Several books on Lex and Yacc are
available.
Yacc allows the syntax of a language to be described using context-free
expressions.  The Yacc compiler compiles these to produce tables to drive
an LALR parser to parse the language.  When a complete phrase has been
found, a user-specified set of actions (written in C) is executed to
produce the desired output, with special variable forms such as <tt>$1</tt>
etc. used to refer to the results associated with the symbols in the
grammar production.  Yacc is designed to use Lex by calling a routine
<tt>yylex</tt> to get the next token and by getting the value of the token
through the variable <tt>yylval</tt>.
<P>
If you wish, you can use your scanner program (rather than Lex program)
with Yacc by: (1) renaming it <tt>yylex</tt>; (2) setting the variable
<tt>yylval</tt> to the token value; and (3)  returning as the value of
<tt>yylex</tt> the operator number added to <tt>OPERATOR_BIAS</tt>, etc.
<P>

<H3>Auxiliary Routines:</H3>
<P>
Routines for handling a symbol table and for pretty-printing intermediate
code trees are provided in the files <tt>symtab.c</tt> and <tt>pprint.c</tt>;
for Lisp, the files <tt>symtab.lsp</tt> and <tt>tokendefs.lsp</tt> contain
similar functions.  The files <tt>token.txt</tt> and  <tt>symtab.txt</tt>
describe token and symbol table entries.
<P>
<H3>Intermediate Code:</H3>
<P>
The form of intermediate code will be abstract syntax trees using the same
tokens as
in the first two assignments.  The file <tt>token.h</tt> provides
constant values needed for Yacc or for a parser written in C;
<tt>tokendefs.lsp</tt> has definitions for Lisp.  Operators
<tt>fix</tt> and <tt>float</tt> are defined to convert between fixed point
(integer) and floating point; these will be generated by the compiler
when needed.
See the file <tt>pprint.c</tt> or <tt>tokendefs.lsp</tt> for a complete list
of operator codes.  File <tt>trivb.tree</tt> shows the tree structure for
<tt>trivb.pas</tt>.
<P>
In addition to expression trees representing assignment statements, we will
use trees with additional operators to represent
other intermediate code statements:
<P>
<TABLE>
<TR><TD>
statement list: </TD><TD> <tt>(progn </tt> <I> statement1  ...   statementn</I>
 <tt>)</tt></TD></TR>
<TR><TD>
conditional branch: </TD><TD> <tt>(if </tt> <I> exp &nbsp statement1 &nbsp statement2</I>
 <tt>)</tt>  or <tt>(if </tt> <I> exp &nbsp statement1</I> <tt>)</tt>  </TD></TR>

<TR><TD>goto:  </TD><TD> <tt>(goto </tt> <I> n </I> <tt>)</tt> where
    <I>n</I> is an integer number token.</TD></TR>

<TR><TD>label:  </TD><TD> <tt>(label </tt> <I> n </I> <tt>)</tt> </TD></TR>

<TR><TD>function call:  </TD><TD> <tt>(funcall </tt> <I>fn &nbsp arg1  ...  argn</I>
 <tt>)</tt> </TD></TR>

<TR><TD>array reference:  </TD><TD> <tt>(aref </tt> <I> base &nbsp offset </I>
 <tt>)</tt> </TD></TR>

<TR><TD>program:  </TD><TD> <tt>(program </tt> <I> name </I>
 <tt>(progn </tt> <I> args </I> <tt>)</tt> <I> code </I>
 <tt>)</tt> </TD></TR>
</TABLE>
<P>
Only these forms are used in the intermediate code; other
constructs, such as <tt>for</tt> loops, must be converted to these basic
forms by the parser. The following is an example of output for
<tt>graph1.pas</tt>; variations such as <B>extra nested <tt>progn</tt> groups
are okay</B>.  White space does not matter, but level of parenthesis
nesting (shown by vertical alignment) does matter.
<PRE>
(program graph1
         (progn output)
         (progn (:= i 0)
                (label 1)
                (if (<= i 32)
                    (progn (:= x (* 6.250000e-02
                                    (float i)))
                           (:= y (* (funcall exp (- x))
                                    (funcall sin (* 6.283180e+00 x))))
                           (:= n (fix (+ (funcall round
                                                  (* 3.200000e+01 y))
                                         3.400000e+01)))
                           (progn (label 0)
                                  (funcall write ' ')
                                  (:= n (- n 1))
                                  (if (= n 0)
                                      (progn)
                                      (goto 0)))
                           (funcall writeln '*')
                           (:= i (+ i 1))
                           (goto 1)))))
</PRE>
<P>
<b>Testing:</b>
<P>
Test your program on the files <tt>trivb.pas</tt>,  <tt>graph1.pas</tt>, and
<tt>pasrec.pas</tt> .   <tt>graph1.pas</tt> is taken from the Jensen and Wirth
book, while <tt>pasrec.pas</tt> exercises pointer, record, and
array operations; we will compile them to machine code and execute them.


</BODY>

</HTML>

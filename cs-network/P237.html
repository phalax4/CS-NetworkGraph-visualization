<base href="http://www.cs.utexas.edu/users/novak/cs314contents.html">
<HTML>
<!--  cs314contents.html          G. Novak     19 Aug 16    -->
<HEAD>
<TITLE>CS 314: Data Structures: Lecture Notes</TITLE>
</HEAD>

<BODY>
<H2>CS 314: Data Structures: Lecture Notes</H2>
<HR>
<P>
Copyright &#169; by Gordon S. Novak Jr.
<P>
Permission is granted for individuals to make copies of these notes
for personal use, or for instructors to make copies for classroom use.
<p>
<B>Note:</B> Some of these pages use math symbols.
Microsoft Internet Explorer will not display the math symbols, but
<a href="http://www.mozilla.com">Firefox</a> will.
<P>
<a href="cs314index.html">Index</a><P>
<P>
<A href="cs3141.html">1. CS 314: Data Structures</A><BR>
<A href="cs3142.html">2. Course Topics</A><BR>
<A href="cs3143.html">3. Introduction</A><BR>
<A href="cs3144.html">4. eine kleine LispMusik</A><BR>
<A href="cs3145.html">5. Fibonacci Numbers</A><BR>
<A href="cs3146.html">6. Fibonacci Functions</A><BR>
<A href="cs3147.html">7. Testing Fibonacci</A><BR>
<A href="cs3148.html">8. Rates of Growth</A><BR>
<A href="cs3149.html">9. Exponential Growth</A><BR>
<A href="cs31410.html">10. Goals of the Course</A><BR>
<A href="cs31411.html">11. Big O and Performance</A><BR>
<A href="cs31412.html">12. Big O</A><BR>
<A href="cs31413.html">13. Big O: An Upper Bound</A><BR>
<A href="cs31414.html">14. Rules for Big O</A><BR>
<A href="cs31415.html">15. Classes of Algorithms</A><BR>
<A href="cs31416.html">16. Log n Grows Slowly</A><BR>
<A href="cs31417.html">17. Log n Is Almost the Same as 1</A><BR>
<A href="cs31418.html">18. Powers of 10: SI Prefixes</A><BR>
<A href="cs31419.html">19. A Scientist Should Be Careful, Skeptical</A><BR>
<A href="cs31420.html">20. Finding Big O: Log-log Graph</A><BR>
<A href="cs31421.html">21. Log-log Example</A><BR>
<A href="cs31422.html">22. Finding Big O: Semi-Log Graph</A><BR>
<A href="cs31423.html">23. Big O from Timing Ratio</A><BR>
<A href="cs31424.html">24. Computation Model</A><BR>
<A href="cs31425.html">25. Big O from Code</A><BR>
<A href="cs31426.html">26. Big O of Loops</A><BR>
<A href="cs31427.html">27. Beware the Bermuda Triangle</A><BR>
<A href="cs31428.html">28. Big O for Arrays</A><BR>
<A href="cs31429.html">29. Average Case vs. Worst Case</A><BR>
<A href="cs31430.html">30. Familiarity with Big O</A><BR>
<A href="cs31431.html">31. Pointer / Reference</A><BR>
<A href="cs31432.html">32. Boxed Number</A><BR>
<A href="cs31433.html">33. References and <tt>==</tt> </A><BR>
<A href="cs31434.html">34. {\tt ==} vs. <tt>.equals()</tt> </A><BR>
<A href="cs31435.html">35. Linked List</A><BR>
<A href="cs31436.html">36. Constructing a Linked List</A><BR>
<A href="cs31437.html">37. Access to Parts of a List</A><BR>
<A href="cs31438.html">38. List Access Functions </A><BR>
<A href="cs31439.html">39. Iterative Processing of List</A><BR>
<A href="cs31440.html">40. Iterative List Design Pattern</A><BR>
<A href="cs31441.html">41. Recursion</A><BR>
<A href="cs31442.html">42. Designing Recursive Functions</A><BR>
<A href="cs31443.html">43. Design Pattern for Recursive Functions</A><BR>
<A href="cs31444.html">44. Recursive Processing of List</A><BR>
<A href="cs31445.html">45. Recursive List Design Pattern</A><BR>
<A href="cs31446.html">46. Tail Recursive Processing of List</A><BR>
<A href="cs31447.html">47. Tail Recursive List Design Pattern</A><BR>
<A href="cs31448.html">48. Constructive Linked List: Reverse</A><BR>
<A href="cs31449.html">49. Tail Recursive Reverse</A><BR>
<A href="cs31450.html">50. Tail Recursive Reverse in Java</A><BR>
<A href="cs31451.html">51. Copying a List</A><BR>
<A href="cs31452.html">52. Append</A><BR>
<A href="cs31453.html">53. Iterative Append</A><BR>
<A href="cs31454.html">54. Destructive Linked List Functions</A><BR>
<A href="cs31455.html">55. Nconc</A><BR>
<A href="cs31456.html">56. Nreverse</A><BR>
<A href="cs31457.html">57. Set as Linked List</A><BR>
<A href="cs31458.html">58. Intersection</A><BR>
<A href="cs31459.html">59. Tail-Recursive Intersection</A><BR>
<A href="cs31460.html">60. Tail-Recursive Intersection in Java</A><BR>
<A href="cs31461.html">61. Union and Set Difference</A><BR>
<A href="cs31462.html">62. Circularly Linked List</A><BR>
<A href="cs31463.html">63. Merge</A><BR>
<A href="cs31464.html">64. Constructive Merge</A><BR>
<A href="cs31465.html">65. Tail Recursive Merge</A><BR>
<A href="cs31466.html">66. Tail Recursive Merge in Java</A><BR>
<A href="cs31467.html">67. Destructive Merge Function</A><BR>
<A href="cs31468.html">68. Iterative Destructive Merge</A><BR>
<A href="cs31469.html">69. Java Iterative Destructive Merge</A><BR>
<A href="cs31470.html">70. Comparison in Java</A><BR>
<A href="cs31471.html">71. Comparator in Java</A><BR>
<A href="cs31472.html">72. Complex Comparator</A><BR>
<A href="cs31473.html">73. Divide and Conquer</A><BR>
<A href="cs31474.html">74. Dividing a List</A><BR>
<A href="cs31475.html">75. Sorting by Merge</A><BR>
<A href="cs31476.html">76. Tracing Sort and Merge</A><BR>
<A href="cs31477.html">77. On Not Dropping the Ball</A><BR>
<A href="cs31478.html">78. Divide and Conquer Design Pattern</A><BR>
<A href="cs31479.html">79. Intersection by Merge</A><BR>
<A href="cs31480.html">80. Merge Technique</A><BR>
<A href="cs31481.html">81. Sort, then Merge</A><BR>
<A href="cs31482.html">82. Association List</A><BR>
<A href="cs31483.html">83. Stack using Linked List</A><BR>
<A href="cs31484.html">84. Sentinel Node</A><BR>
<A href="cs31485.html">85. Other Uses of Linked Lists</A><BR>
<A href="cs31486.html">86. Arrays</A><BR>
<A href="cs31487.html">87. Stack using Array</A><BR>
<A href="cs31488.html">88. Uses of Stacks</A><BR>
<A href="cs31489.html">89. Recursion and Runtime Stack</A><BR>
<A href="cs31490.html">90. Recursive Function Execution</A><BR>
<A href="cs31491.html">91. Recursive Execution ...</A><BR>
<A href="cs31492.html">92. Recursive Length Function Execution</A><BR>
<A href="cs31493.html">93. Balancing Parentheses</A><BR>
<A href="cs31494.html">94. Balance Test Using Stack</A><BR>
<A href="cs31495.html">95. Linked List Stack</A><BR>
<A href="cs31496.html">96. Tree Traversal and Stack</A><BR>
<A href="cs31497.html">97. XML</A><BR>
<A href="cs31498.html">98. Stack in Plain Code</A><BR>
<A href="cs31499.html">99. Queues</A><BR>
<A href="cs314100.html">100. Two Pointer Queue using Linked List</A><BR>
<A href="cs314101.html">101. Circular Queue using Array</A><BR>
<A href="cs314102.html">102. Circular Queue Code</A><BR>
<A href="cs314103.html">103. Java Collection API</A><BR>
<A href="cs314104.html">104. Java Collections Iteration</A><BR>
<A href="cs314105.html">105. Filter Pattern</A><BR>
<A href="cs314106.html">106. Using Library Packages</A><BR>
<A href="cs314107.html">107. Java List Interface</A><BR>
<A href="cs314108.html">108. ArrayList</A><BR>
<A href="cs314109.html">109. LinkedList</A><BR>
<A href="cs314110.html">110. ListIterator</A><BR>
<A href="cs314111.html">111. Comparing ArrayList and LinkedList</A><BR>
<A href="cs314112.html">112. Trees</A><BR>
<A href="cs314113.html">113. Arithmetic Expressions as Trees</A><BR>
<A href="cs314114.html">114. Computer Programs as Trees</A><BR>
<A href="cs314115.html">115. English Sentences as Trees</A><BR>
<A href="cs314116.html">116. File Systems as Trees</A><BR>
<A href="cs314117.html">117. Phylogenetic Trees</A><BR>
<A href="cs314118.html">118. Taxonomies as Trees</A><BR>
<A href="cs314119.html">119. Ontologies as Trees</A><BR>
<A href="cs314120.html">120. Organizations as Trees</A><BR>
<A href="cs314121.html">121. Nerves</A><BR>
<A href="cs314122.html">122. Representations of Trees</A><BR>
<A href="cs314123.html">123. Binary Tree</A><BR>
<A href="cs314124.html">124. First-Child / Next-Sibling Tree</A><BR>
<A href="cs314125.html">125. First-Child / Next-Sibling Example</A><BR>
<A href="cs314126.html">126. Linked List Tree</A><BR>
<A href="cs314127.html">127. Implicit Tree</A><BR>
<A href="cs314128.html">128. Binary Search Tree (BST)</A><BR>
<A href="cs314129.html">129. Binary Tree Search</A><BR>
<A href="cs314130.html">130. Binary Search of Array</A><BR>
<A href="cs314131.html">131. Binary Tree Array Search</A><BR>
<A href="cs314132.html">132. Binary Array Search Example</A><BR>
<A href="cs314133.html">133. Binary Tree Recursion</A><BR>
<A href="cs314134.html">134. Binary Tree Recursion</A><BR>
<A href="cs314135.html">135. Design Pattern: Binary Tree Recursion</A><BR>
<A href="cs314136.html">136. Binary Tree Recursion Pattern in Java</A><BR>
<A href="cs314137.html">137. Design Pattern: Binary Tree Recursion</A><BR>
<A href="cs314138.html">138. Searching Directories for a File</A><BR>
<A href="cs314139.html">139. Findpath Example</A><BR>
<A href="cs314140.html">140. Findpath Representation</A><BR>
<A href="cs314141.html">141. Java Version of Findpath</A><BR>
<A href="cs314142.html">142. Lisp Version of Findpath</A><BR>
<A href="cs314143.html">143. Searching Directories Example</A><BR>
<A href="cs314144.html">144. Searching Directories Example ...</A><BR>
<A href="cs314145.html">145. Big O for Trees</A><BR>
<A href="cs314146.html">146. Depth First Search</A><BR>
<A href="cs314147.html">147. Depth First Search Order</A><BR>
<A href="cs314148.html">148. Robot Mouse in Maze</A><BR>
<A href="cs314149.html">149. Robot Mouse in Java</A><BR>
<A href="cs314150.html">150. Robot Mouse Program</A><BR>
<A href="cs314151.html">151. Robot Mouse Example</A><BR>
<A href="cs314152.html">152. Tracing the Robot Mouse</A><BR>
<A href="cs314153.html">153. Tracing the Robot Mouse ...</A><BR>
<A href="cs314154.html">154. Tree Traversal</A><BR>
<A href="cs314155.html">155. Preorder</A><BR>
<A href="cs314156.html">156. Preorder Example</A><BR>
<A href="cs314157.html">157. Preorder Example in Java</A><BR>
<A href="cs314158.html">158. Inorder</A><BR>
<A href="cs314159.html">159. Inorder Printing of Binary Tree</A><BR>
<A href="cs314160.html">160. Flattening Binary Tree</A><BR>
<A href="cs314161.html">161. Tracing Flattening Binary Tree</A><BR>
<A href="cs314162.html">162. Flattening Binary Tree in Java</A><BR>
<A href="cs314163.html">163. Postorder</A><BR>
<A href="cs314164.html">164. Balanced Binary Trees</A><BR>
<A href="cs314165.html">165. AVL Tree</A><BR>
<A href="cs314166.html">166. Tree Rotation</A><BR>
<A href="cs314167.html">167. B-Tree</A><BR>
<A href="cs314168.html">168. B-Tree Implementation</A><BR>
<A href="cs314169.html">169. Advantages of B-Trees</A><BR>
<A href="cs314170.html">170. Quadtree</A><BR>
<A href="cs314171.html">171. Image Quadtree</A><BR>
<A href="cs314172.html">172. Intersection of Quadtrees</A><BR>
<A href="cs314173.html">173. Aggregate Data in Quadtrees</A><BR>
<A href="cs314174.html">174. Uses of Quadtrees</A><BR>
<A href="cs314175.html">175. Be Extreme!</A><BR>
<A href="cs314176.html">176. Sparse Arrays</A><BR>
<A href="cs314177.html">177. Solving Equations</A><BR>
<A href="cs314178.html">178. Solving an Equation by Search</A><BR>
<A href="cs314179.html">179. Examples: Base Cases</A><BR>
<A href="cs314180.html">180. Recursive Cases: Operators</A><BR>
<A href="cs314181.html">181. Recursive Tree Search</A><BR>
<A href="cs314182.html">182. Big O and Termination</A><BR>
<A href="cs314185.html">185. Solving a Set of Equations by Search</A><BR>
<A href="cs314186.html">186. Solving Physics Story Problems</A><BR>
<A href="cs314187.html">187. Pattern Matching Overview</A><BR>
<A href="cs314188.html">188. Copy Tree and Substitute</A><BR>
<A href="cs314189.html">189. Copy Tree and Substitute in Java</A><BR>
<A href="cs314190.html">190. Binding Lists</A><BR>
<A href="cs314191.html">191. Multiple Substitutions</A><BR>
<A href="cs314192.html">192. Sublis in Java</A><BR>
<A href="cs314193.html">193. Instantiating Design Patterns</A><BR>
<A href="cs314194.html">194. Tree Equality</A><BR>
<A href="cs314195.html">195. Tree Equality in Java</A><BR>
<A href="cs314196.html">196. Tracing Equal</A><BR>
<A href="cs314197.html">197. Design Pattern: Nested Tree Recursion</A><BR>
<A href="cs314198.html">198. Tracing Nested Tree Recursion</A><BR>
<A href="cs314199.html">199. Pattern Matching</A><BR>
<A href="cs314200.html">200. Specifications of Match</A><BR>
<A href="cs314201.html">201. Match Function</A><BR>
<A href="cs314202.html">202. Match Function in Java</A><BR>
<A href="cs314203.html">203. Transformation by Patterns</A><BR>
<A href="cs314204.html">204. Transformation Patterns</A><BR>
<A href="cs314205.html">205. Program Transformation using Lisp</A><BR>
<A href="cs314206.html">206. Programs and Trees</A><BR>
<A href="cs314207.html">207. Set API in Java</A><BR>
<A href="cs314208.html">208. Map API in Java</A><BR>
<A href="cs314209.html">209. Iteration over a <tt>Map</tt></A><BR>
<A href="cs314210.html">210. Array as a <tt>Map</tt></A><BR>
<A href="cs314211.html">211. Avoid Repeated Code </A><BR>
<A href="cs314212.html">212. Initializing Array </A><BR>
<A href="cs314213.html">213. Key of a <tt>Map</tt></A><BR>
<A href="cs314214.html">214. Hashing</A><BR>
<A href="cs314215.html">215. Hash Function</A><BR>
<A href="cs314216.html">216. Java <tt>.hashCode()</tt></A><BR>
<A href="cs314217.html">217. Exclusive OR</A><BR>
<A href="cs314218.html">218. Uses of Exclusive OR</A><BR>
<A href="cs314219.html">219. Hash Function for Strings</A><BR>
<A href="cs314220.html">220. Hash Function for Application Types</A><BR>
<A href="cs314221.html">221. Collisions</A><BR>
<A href="cs314222.html">222. Hashing with Buckets</A><BR>
<A href="cs314223.html">223. Hashing with Buckets: Code</A><BR>
<A href="cs314224.html">224. Rehashing</A><BR>
<A href="cs314225.html">225. Hash Tables in Java</A><BR>
<A href="cs314226.html">226. Extendible Hashing</A><BR>
<A href="cs314227.html">227. Uses of Hashing</A><BR>
<A href="cs314228.html">228. Randomization</A><BR>
<A href="cs314229.html">229. Priority Queue</A><BR>
<A href="cs314230.html">230. Priority Queue with Array or Binary Tree</A><BR>
<A href="cs314231.html">231. Binary Heap</A><BR>
<A href="cs314232.html">232. Mapping to Array</A><BR>
<A href="cs314233.html">233. Insertion into Heap</A><BR>
<A href="cs314234.html">234. Removal from Heap</A><BR>
<A href="cs314235.html">235. Uses of Priority Queues</A><BR>
<A href="cs314236.html">236. <tt>PriorityQueue</tt> in Java</A><BR>
<A href="cs314237.html">237. Example Discrete Event Simulation</A><BR>
<A href="cs314238.html">238. Sorting</A><BR>
<A href="cs314239.html">239. Insertion Sort</A><BR>
<A href="cs314240.html">240. Insertion Sort Performance</A><BR>
<A href="cs314241.html">241. Heapsort</A><BR>
<A href="cs314242.html">242. Merge Sort</A><BR>
<A href="cs314243.html">243. Merge Sort Performance</A><BR>
<A href="cs314244.html">244. Memory Hierarchy and Locality</A><BR>
<A href="cs314245.html">245. Does Array Index Order Matter?</A><BR>
<A href="cs314246.html">246. Array Storage and Indexing</A><BR>
<A href="cs314247.html">247. Quicksort</A><BR>
<A href="cs314248.html">248. Quicksort Code</A><BR>
<A href="cs314249.html">249. Partitioning</A><BR>
<A href="cs314250.html">250. Quicksort Example</A><BR>
<A href="cs314251.html">251. Quicksort Performance</A><BR>
<A href="cs314252.html">252. Radix Sort</A><BR>
<A href="cs314253.html">253. Radix Sort Example</A><BR>
<A href="cs314254.html">254. Sorting in Java Library</A><BR>
<A href="cs314255.html">255. Graphs</A><BR>
<A href="cs314256.html">256. Examples of Graphs</A><BR>
<A href="cs314257.html">257. Directed Acyclic Graph</A><BR>
<A href="cs314258.html">258. Graph Representations</A><BR>
<A href="cs314259.html">259. Adjacency List</A><BR>
<A href="cs314260.html">260. Adjacency Matrix</A><BR>
<A href="cs314261.html">261. Implicit Graphs</A><BR>
<A href="cs314262.html">262. Topological Sort</A><BR>
<A href="cs314263.html">263. Uses of Topological Sort</A><BR>
<A href="cs314264.html">264. PERT Chart</A><BR>
<A href="cs314265.html">265. PERT Chart: Calculating Times</A><BR>
<A href="cs314266.html">266. Shortest Path Problem</A><BR>
<A href="cs314267.html">267. Dijkstra's Algorithm</A><BR>
<A href="cs314268.html">268. Dijkstra's Algorithm</A><BR>
<A href="cs314269.html">269. Dijkstra's Algorithm Example</A><BR>
<A href="cs314270.html">270. Minimum Spanning Tree</A><BR>
<A href="cs314271.html">271. Prim's Algorithm</A><BR>
<A href="cs314272.html">272. Prim's Algorithm</A><BR>
<A href="cs314273.html">273. Prim's Algorithm Example</A><BR>
<A href="cs314274.html">274. Directed Search</A><BR>
<A href="cs314275.html">275. Hill Climbing</A><BR>
<A href="cs314276.html">276. Heuristic Search: A*</A><BR>
<A href="cs314277.html">277. A* Algorithm</A><BR>
<A href="cs314278.html">278. Ordered Search for Route Finding</A><BR>
<A href="cs314279.html">279. Effect of Heuristic Function</A><BR>
<A href="cs314280.html">280. Heuristic Search Handles Local Maxima</A><BR>
<A href="cs314281.html">281. A* Algorithm Example</A><BR>
<A href="cs314282.html">282. Graph Search Algorithm Summary</A><BR>
<A href="cs314283.html">283. Microcontrollers</A><BR>
<A href="cs314284.html">284. Arduino Programming</A><BR>
<A href="cs314285.html">285. Resources</A><BR>
<A href="cs314286.html">286. Mapping</A><BR>
<A href="cs314287.html">287. Implementation of Mapping</A><BR>
<A href="cs314288.html">288. Functional Programming</A><BR>
<A href="cs314289.html">289. Associative and Commutative</A><BR>
<A href="cs314290.html">290. Computation as Simulation</A><BR>
<A href="cs314291.html">291. Mapping in Lisp</A><BR>
<A href="cs314292.html">292. Mapcan</A><BR>
<A href="cs314293.html">293. Input Filtering and Mapping</A><BR>
<A href="cs314294.html">294. Reduce in Lisp</A><BR>
<A href="cs314295.html">295. Combining Map and Reduce</A><BR>
<A href="cs314296.html">296. MapReduce and Massive Data</A><BR>
<A href="cs314297.html">297. Distributed Programming is Hard!</A><BR>
<A href="cs314298.html">298. What MapReduce Does for Us</A><BR>
<A href="cs314299.html">299. Map Sort Reduce</A><BR>
<A href="cs314300.html">300. Simplified MapReduce</A><BR>
<A href="cs314301.html">301. Mapreduce in Lisp</A><BR>
<A href="cs314302.html">302. Simple MapReduce Example</A><BR>
<A href="cs314303.html">303. MapReduce Example</A><BR>
<A href="cs314304.html">304. Hamburger Example</A><BR>
<A href="cs314305.html">305. How MapReduce Works</A><BR>
<A href="cs314306.html">306. Map Worker</A><BR>
<A href="cs314307.html">307. Buffering</A><BR>
<A href="cs314308.html">308. Load Balancing</A><BR>
<A href="cs314309.html">309. Reduce Worker</A><BR>
<A href="cs314310.html">310. PageRank</A><BR>
<A href="cs314311.html">311. PageRank Example</A><BR>
<A href="cs314312.html">312. Running PageRank Example</A><BR>
<A href="cs314313.html">313. Advanced Performance</A><BR>
<A href="cs314314.html">314. Performance Techniques in MapReduce</A><BR>
<A href="cs314315.html">315. Algorithm Failure</A><BR>
<A href="cs314316.html">316. Atomic Commit</A><BR>
<HR>
<a href="cs314.html">CS 314</a><BR>
</BODY>
</HTML>

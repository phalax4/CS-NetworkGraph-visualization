<base href="http://www.cs.utexas.edu/users/novak/cs314clindex.html">
<HTML> <HEAD> <TITLE>Clicker Questions</TITLE> </HEAD>
<BODY>

<H2>Clicker Questions</H2>

<a href="cs314cl1.html">1: <I>O(n)</I> loop followed by another <I>O(n)</I> loop</a><br>
<a href="cs314cl2.html">2: <I>log(student wealth) / log(Bill Gates wealth)</I> </a><br>
<a href="cs314cl3.html">3: How many bits in a word on your computer?</a><br>
<a href="cs314cl4.html">4: Can the national debt be stored in an <TT> int</TT></a><br>
<a href="cs314cl5.html">5: time plot on log-log paper curves up</a><br>
<a href="cs314cl6.html">6: input size increases by 2, time by 8</a><br>
<a href="cs314cl7.html">7: What benefit does <TT> Integer</TT> provide</a><br>
<a href="cs314cl8.html">8: <TT> Integer</TT> is <I> immutable</I> ... what happens</a><br>
<a href="cs314cl9.html">9: Big O of <TT>int n = myarray.length;</TT></a><br>
<a href="cs314cl10.html">10: <TT>int [] myarray = new int[1000];</TT> storage</a><br>
<a href="cs314cl11.html">11: <TT>Integer [] myarray = new Integer[1000];</TT> storage</a><br>
<a href="cs314cl11b.html">11b: Are <TT>3.0</TT> and <TT>0.3</TT> represented exactly?</a><br>
<a href="cs314cl12.html">12: What is <TT> (cons '(a) '(b))</TT> ?</a><br>
<a href="cs314cl13.html">13: What is <TT> (first '((a b) (c d)))</TT> ?</a><br>
<a href="cs314cl14.html">14: What is <TT> (rest '((a b) (c d)))</TT> ?</a><br>
<a href="cs314cl15.html">15: <TT> (rest (rest '((a b) (c d))))</TT> ?</a><br>
<a href="cs314cl16.html">16: <TT> (length '((a b) (c d)) )</TT> ?</a><br>
<a href="cs314cl17.html">17: <TT> (reverse '((a b) (c d)) )</TT> ?</a><br>
<a href="cs314cl18.html">18: <TT>lst = cons( i, lst );</TT> in a loop</a><br>
<a href="cs314cl19.html">19: runtime type of <TT> first(lst)</TT></a><br>
<a href="cs314cl20.html">20: <TT> (append '(a b) '(c d))</TT> ?</a><br>
<a href="cs314cl21.html">21: Big O of <TT>Cons lst = append(x, y); </TT></a><br>
<a href="cs314cl22.html">22: <TT> ( lst == reverse(reverse(lst)) )</TT></a><br>
<a href="cs314cl23.html">23: <TT>( first(lst) == first(reverse(reverse(lst))) )</TT></a><br>
<a href="cs314cl24.html">24: <TT>lst = append( list(i), lst );</TT> in a loop</a><br>
<a href="cs314cl25.html">25: Big O of <TT>lst = append( list(i), lst );</TT> in a loop</a><br>
<a href="cs314cl26.html">26: <TT>lst = append( lst, list(i) );</TT> in a loop</a><br>
<a href="cs314cl27.html">27: Big O of <TT>lst = append( lst, list(i) );</TT> in a loop</a><br>
<a href="cs314cl28.html">28: <TT>lst = cons( i, lst );</TT> in a loop,
<TT>lst = nreverse(lst);</TT></a><br>
<a href="cs314cl29.html">29: Big O of the above</a><br>
<a href="cs314cl30.html">30: after above, type of <TT> first(lst)</TT> as seen by the compiler</a><br>
<a href="cs314cl31.html">31: <TT> (intersection '(c r e a m) '(s u g a r))</TT></a><br>
<a href="cs314cl32.html">32: <TT> (union '(c r e a m) '(s u g a r))</TT></a><br>
<a href="cs314cl33.html">33: <TT> (set-difference '(c r e a m) '(s u g a r))</TT></a><br>
<a href="cs314cl34.html">34: <TT> (intersection '(r a t) '(f i n k))</TT></a><br>
<a href="cs314cl35.html">35: <TT> (set-difference '(r a t) '(f i n k))</TT></a><br>
<a href="cs314cl36.html">36: on a Stack: (push 1) (push 2) (push 3) (pop) (pop) (push 4) (pop) (pop)</a><br>
<a href="cs314cl37.html">37: Big O of set intersection, done well?</a><br>
<a href="cs314cl38.html">38: on a Queue:
(insert 1) (insert 2) (insert 3) (remove) (remove) (insert 4) (remove) (remove)</a><br>
<a href="cs314cl39.html">39: Big O of <TT>sum += lst.get(i);</TT> on <TT>ArrayList</TT></a><br>
<a href="cs314cl40.html">40: Big O of <TT>sum += lst.get(i);</TT> on <TT>LinkedList</TT></a><br>
<a href="cs314cl41.html">41: Big O of <TT>for (Integer i : lst )  sum += i;</TT> on <TT>LinkedList</TT></a><br>
<a href="cs314cl41b.html">41b: Is <tt>every</tt> thing in the empty list (<tt>null</tt>) a number?</a><br>
<a href="cs314cl41c.html">41c: Is <tt>some</tt> thing in the empty list (<tt>null</tt>) a number?</a><br>
<a href="cs314cl42.html">42: Java corresponding to tree</a><br>
<a href="cs314cl43.html">43: advantages of the first-child / next-sibling representation of trees</a><br>
<a href="cs314cl44.html">44: Big O of finding an item in a balanced BST</a><br>
<a href="cs314cl45.html">45: What kind of tree is most similar to our directory tree?</a><br>
<a href="cs314cl46.html">46: order in which nodes of tree are visited
in depth-first order</a><br>
<a href="cs314cl47.html">47: order in which nodes of tree are processed
in inorder</a><br>
<a href="cs314cl48.html">48: order in which nodes of tree are processed
in postorder</a><br>
<a href="cs314cl49.html">49: order in which nodes of tree are processed
in preorder</a><br>
<a href="cs314cl50.html">50: Why do binary search trees need to be balanced?</a><br>
<a href="cs314cl51.html">51: branching factor <I> b</I> for tree with <I> n = 1,000,000,000</I> elements to have a depth <I> d</I> of 3?</a><br>
<a href="cs314cl52.html">52: how long does it take to read a record from a disc drive?</a><br>
<a href="cs314cl53.html">53: divide a 1 TB disc drive among all possible SSNs</a><br>
<a href="cs314cl54.html">54: <TT> ( list("a") == list("a") )</TT></a><br>
<a href="cs314cl55.html">55: <TT> (subst 'crazy 'beauty '(beauty is as beauty does))</TT></a><br>
<a href="cs314cl56.html">56: <TT> (sublis '((z 4) (y 3) (x 2)) '(* x y))</TT></a><br>
<a href="cs314cl57.html">57: <TT> ( list("a").equals(list("a")) )</TT></a><br>
<a href="cs314cl58.html">58: <TT> (match '(- ?x ?y) '(- w 3))</TT></a><br>
<a href="cs314cl59.html">59: <TT> (match '(- ?x ?x) '(- w 3))</TT></a><br>
<a href="cs314cl60.html">60: What is <I>not</I> true of <TT> .hashCode()</TT> in Java?</a><br>
<a href="cs314cl61.html">61: load factor (fullness) <I>&lambda; &lt; 0.7</I> in a hash table</a><br>
<a href="cs314cl62.html">62: Big O of hashing when <I>&lambda; &lt; 0.7</I></a><br>
<a href="cs314cl63.html">63: advantage of hashing with buckets</a><br>
<a href="cs314cl64.html">64: Big O of hashing with buckets</a><br>
<a href="cs314cl65.html">65: inserted into a min priority queue <TT> ((A, 2), (B, 3), (C, 1), (D, 2), (E, 1))</TT></a><br>
<a href="cs314cl66.html">66: advantage of heap for storing priority queue</a><br>
<a href="cs314cl67.html">67: data structure used for a heap</a><br>
<a href="cs314cl68.html">68: What is <I> not</I> true about Insertion Sort?</a><br>
<a href="cs314cl69.html">69: What is true about Quicksort?</a><br>
<a href="cs314cl70.html">70: What is true about Heapsort?</a><br>
<a href="cs314cl71.html">71: number of possible graphs with n nodes</a><br>
<a href="cs314cl72.html">72: Suppose each user of Facebook has 1000 friends. Is that graph...</a><br>
<a href="cs314cl73.html">73: family tree (ancestry) as a graph</a><br>
<a href="cs314cl74.html">74: What does Prim's algorithm guarantee?</a><br>
<a href="cs314cl75.html">75: What does Dijkstra's algorithm produce?</a><br>
<a href="cs314cl76.html">76: What advantage might A* have over Dijkstra's Algorithm?</a><br>
<a href="cs314cl77.html">77: What does A* assume that Dijkstra does not?</a><br>
<a href="cs314cl78.html">78: What is true of heuristic functions for A*?</a><br>
<a href="cs314cl79.html">79: What kind of problem is MapReduce good for?</a><br>

</BODY> </HTML>
